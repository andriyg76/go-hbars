package compiler

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/andriyg76/go-hbars/internal/ast"
	"github.com/andriyg76/go-hbars/internal/parser"
	"github.com/andriyg76/hexerr"
)

// HelperRef points to a helper implementation.
type HelperRef struct {
	ImportPath string
	Ident      string
}

// Options configures code generation.
type Options struct {
	PackageName       string
	RuntimeImport     string
	Helpers           map[string]HelperRef
	GenerateBootstrap bool   // Generate bootstrap code for server/processor
	GeneratorVersion  string // If set, emitted in generated file as "// Generator version: ..."
}

// CompileTemplates compiles templates into Go source code.
func CompileTemplates(templates map[string]string, opts Options) ([]byte, error) {
	if opts.PackageName == "" {
		return nil, hexerr.New("compiler: package name is required")
	}
	runtimeImport := opts.RuntimeImport
	if runtimeImport == "" {
		runtimeImport = "github.com/andriyg76/go-hbars/runtime"
	}
	helperExprs, helperImports, err := prepareHelpers(opts.Helpers, runtimeImport)
	if err != nil {
		return nil, err
	}

	names := make([]string, 0, len(templates))
	parsed := make(map[string][]ast.Node, len(templates))
	for name, tmpl := range templates {
		nodes, err := parser.Parse(tmpl)
		if err != nil {
			return nil, hexerr.Wrapf(err, "compiler: template %q", name)
		}
		parsed[name] = nodes
		names = append(names, name)
	}
	sort.Strings(names)

	funcNames := make(map[string]string, len(names))
	seenFunc := make(map[string]string, len(names))
	for _, name := range names {
		ident := goIdent(name)
		if prev, exists := seenFunc[ident]; exists {
			return nil, hexerr.New(fmt.Sprintf("compiler: templates %q and %q map to %q", prev, name, ident))
		}
		seenFunc[ident] = name
		funcNames[name] = ident
	}

	usedHelpers := collectUsedHelperNames(parsed, helperExprs)
	helperImports = filterHelperImports(helperImports, opts.Helpers, usedHelpers)

	partialParamTypes := CollectPartialParamTypes(parsed, names, funcNames, helperExprs)

	needFmt := templatesUseBlockHelpers(parsed, helperExprs) || opts.GenerateBootstrap
	useLayoutBlocks := templatesUsesLayoutBlocks(parsed)
	header := &codeWriter{}
	header.line("// Code generated by hbc; DO NOT EDIT.")
	if opts.GeneratorVersion != "" {
		header.line("// Generator version: %s", opts.GeneratorVersion)
	}
	header.line("package %s", opts.PackageName)
	header.line("")
	header.line("import (")
	header.indentInc()
	if needFmt {
		header.line("%q", "fmt")
	}
	header.line("%q", "io")
	header.line("%q", "strings")
	header.line("runtime %q", runtimeImport)
	for _, imp := range helperImports {
		if imp.name == "" {
			header.line("%q", imp.path)
		} else {
			header.line("%s %q", imp.name, imp.path)
		}
	}
	if opts.GenerateBootstrap {
		header.line("%q", "github.com/andriyg76/go-hbars/pkg/renderer")
		header.line("%q", "github.com/andriyg76/go-hbars/pkg/sitegen")
	}
	header.indentDec()
	header.line(")")
	header.line("")

	// Build type trees for all templates.
	typeTrees := make(map[string]*typeNode)
	for _, name := range names {
		col := newPathCollector(helperExprs)
		col.setParsed(parsed)
		if err := col.collectNodes(parsed[name]); err != nil {
			return nil, hexerr.Wrapf(err, "compiler: template %q context inference", name)
		}
		typeTrees[name] = buildTypeTree(col.paths, col.eachFields)
	}

	// Context type -> template name that owns it (so partials can use that template's type tree).
	contextTypeToTemplate := make(map[string]string)
	for _, name := range names {
		goName := funcNames[name]
		ownCtx := goName + "Context"
		paramType := partialParamTypes[name]
		if paramType != "" && paramType != ownCtx {
			continue
		}
		tree := typeTrees[name]
		for _, ctxType := range AllContextTypeNames(goName, tree) {
			contextTypeToTemplate[ctxType] = name
		}
	}

	contextIfaces := &codeWriter{}
	contextData := &codeWriter{}
	for _, name := range names {
		goName := funcNames[name]
		ownCtx := goName + "Context"
		paramType := partialParamTypes[name]
		if paramType != "" && paramType != ownCtx {
			continue // partial uses another template's context; don't emit its own root interface or data
		}
		tree := typeTrees[name]
		emitContextInterfaces(contextIfaces, name, tree)
		emitContextDataTypes(contextData, name, tree)
	}

	partials := &codeWriter{}
	if useLayoutBlocks {
		partials.line("var partials map[string]func(any, io.Writer, *runtime.Blocks) error")
	} else {
		partials.line("var partials map[string]func(any, io.Writer) error")
	}
	partials.line("")
	partials.line("// contextMap returns map[string]any from ctx (either direct map or Raw() from context data).")
	partials.line("func contextMap(ctx any) map[string]any {")
	partials.indentInc()
	partials.line("if m, ok := ctx.(map[string]any); ok { return m }")
	partials.line("type rawer interface{ Raw() any }")
	partials.line("if r, ok := ctx.(rawer); ok {")
	partials.indentInc()
	partials.line("if m, ok := r.Raw().(map[string]any); ok { return m }")
	partials.indentDec()
	partials.line("}")
	partials.line("return nil")
	partials.indentDec()
	partials.line("}")
	partials.line("")
	partials.line("func init() {")
	partials.indentInc()
	if useLayoutBlocks {
		partials.line("partials = map[string]func(any, io.Writer, *runtime.Blocks) error{")
	} else {
		partials.line("partials = map[string]func(any, io.Writer) error{")
	}
	partials.indentInc()
	for _, name := range names {
		goName := funcNames[name]
		ctxType := partialParamTypes[name]
		if ctxType == "" {
			ctxType = goName + "Context"
		}
		fromMapName := strings.TrimSuffix(ctxType, "Context") + "ContextFromMap"
		if useLayoutBlocks {
			partials.line("%q: func(ctx any, w io.Writer, blocks *runtime.Blocks) error {", name)
		} else {
			partials.line("%q: func(ctx any, w io.Writer) error {", name)
		}
		partials.indentInc()
		partials.line("m := contextMap(ctx)")
		partials.line("if m == nil { return nil }")
		if useLayoutBlocks {
			partials.line("return render%s(%s(m), w, blocks)", goName, fromMapName)
		} else {
			partials.line("return render%s(%s(m), w)", goName, fromMapName)
		}
		partials.indentDec()
		partials.line("},")
	}
	partials.indentDec()
	partials.line("}")
	partials.indentDec()
	partials.line("}")
	partials.line("")

	functions := &codeWriter{}
	for _, name := range names {
		goName := funcNames[name]
		nodes := parsed[name]
		rootContext := partialParamTypes[name]
		if rootContext == "" {
			rootContext = goName + "Context"
		}
		// Use the type tree from the template that owns this context (so path resolution uses the right interface).
		ownerName := contextTypeToTemplate[rootContext]
		if ownerName == "" {
			ownerName = name
		}
		tree := typeTrees[ownerName]
		gen := &generator{w: functions, helpers: helperExprs, partials: funcNames, tree: tree, goName: goName}
		if useLayoutBlocks {
			gen.blocksVar = "blocks"
		}
		if useLayoutBlocks {
			functions.line("func render%s(data %s, w io.Writer, blocks *runtime.Blocks) error {", goName, rootContext)
		} else {
			functions.line("func render%s(data %s, w io.Writer) error {", goName, rootContext)
		}
		functions.indentInc()
		functions.line("if data == nil {")
		functions.indentInc()
		functions.line("return nil")
		functions.indentDec()
		functions.line("}")
		gen.pushTypedScope("data", "", tree)
		if err := gen.emitNodes(nodes); err != nil {
			return nil, hexerr.Wrapf(err, "compiler: template %q", name)
		}
		functions.line("return nil")
		functions.indentDec()
		functions.line("}")
		functions.line("")
		functions.line("func Render%s(w io.Writer, data %s) error {", goName, rootContext)
		functions.indentInc()
		if useLayoutBlocks {
			functions.line("return render%s(data, w, nil)", goName)
		} else {
			functions.line("return render%s(data, w)", goName)
		}
		functions.indentDec()
		functions.line("}")
		functions.line("")
		if useLayoutBlocks {
			functions.line("func Render%sWithBlocks(w io.Writer, data %s, blocks *runtime.Blocks) error {", goName, rootContext)
			functions.indentInc()
			functions.line("return render%s(data, w, blocks)", goName)
			functions.indentDec()
			functions.line("}")
			functions.line("")
		}
		functions.line("func Render%sString(data %s) (string, error) {", goName, rootContext)
		functions.indentInc()
		functions.line("var b strings.Builder")
		functions.line("if err := Render%s(&b, data); err != nil {", goName)
		functions.indentInc()
		functions.line("return \"\", err")
		functions.indentDec()
		functions.line("}")
		functions.line("return b.String(), nil")
		functions.indentDec()
		functions.line("}")
		functions.line("")
	}

	// Generate bootstrap code if requested
	bootstrap := &codeWriter{}
	if opts.GenerateBootstrap {
		generateBootstrapCode(bootstrap, names, funcNames, partialParamTypes)
	}

	var out strings.Builder
	out.WriteString(header.String())
	out.WriteString(contextIfaces.String())
	out.WriteString(contextData.String())
	out.WriteString(partials.String())
	out.WriteString(functions.String())
	if bootstrap.String() != "" {
		out.WriteString(bootstrap.String())
	}

	formatted, err := format.Source([]byte(out.String()))
	if err != nil {
		return nil, hexerr.Wrapf(err, "compiler: format")
	}
	return formatted, nil
}

type importSpec struct {
	path string
	name string
}

func prepareHelpers(helpers map[string]HelperRef, runtimeImport string) (map[string]string, []importSpec, error) {
	helperExprs := make(map[string]string)
	if len(helpers) == 0 {
		return helperExprs, nil, nil
	}
	usedNames := map[string]bool{
		"io":      true,
		"strings": true,
		"runtime": true,
	}
	aliases := make(map[string]string)
	names := make([]string, 0, len(helpers))
	for name := range helpers {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		ref := helpers[name]
		if name == "" {
			return nil, nil, hexerr.New("compiler: helper name is empty")
		}
		if ref.Ident == "" {
			return nil, nil, hexerr.New(fmt.Sprintf("compiler: helper %q has empty identifier", name))
		}
		if ref.ImportPath == "" {
			helperExprs[name] = ref.Ident
			continue
		}
		if strings.Contains(ref.Ident, ".") || !isIdent(ref.Ident) {
			return nil, nil, hexerr.New(fmt.Sprintf("compiler: helper %q identifier %q must be a Go identifier", name, ref.Ident))
		}
		if runtimeImport != "" && ref.ImportPath == runtimeImport {
			helperExprs[name] = "runtime." + ref.Ident
			continue
		}
		alias, ok := aliases[ref.ImportPath]
		if !ok {
			base := sanitizeImportName(path.Base(ref.ImportPath))
			alias = uniqueAlias(base, usedNames)
			aliases[ref.ImportPath] = alias
			usedNames[alias] = true
		}
		helperExprs[name] = alias + "." + ref.Ident
	}
	imports := make([]importSpec, 0, len(aliases))
	for importPath, alias := range aliases {
		imports = append(imports, importSpec{path: importPath, name: alias})
	}
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})
	return helperExprs, imports, nil
}

func templatesUseBlockHelpers(parsed map[string][]ast.Node, helperExprs map[string]string) bool {
	builtinBlocks := map[string]bool{"if": true, "unless": true, "with": true, "each": true, "block": true, "partial": true}
	var walk func(nodes []ast.Node) bool
	walk = func(nodes []ast.Node) bool {
		for _, node := range nodes {
			switch n := node.(type) {
			case *ast.Block:
				if !builtinBlocks[n.Name] && helperExprs[n.Name] != "" {
					return true
				}
				if walk(n.Body) || walk(n.Else) {
					return true
				}
			}
		}
		return false
	}
	for _, nodes := range parsed {
		if walk(nodes) {
			return true
		}
	}
	return false
}

// templatesUsesLayoutBlocks reports whether any template uses {{#block}} or {{#partial}}.
func templatesUsesLayoutBlocks(parsed map[string][]ast.Node) bool {
	var walk func(nodes []ast.Node) bool
	walk = func(nodes []ast.Node) bool {
		for _, node := range nodes {
			switch n := node.(type) {
			case *ast.Block:
				if n.Name == "block" || n.Name == "partial" {
					return true
				}
				if walk(n.Body) || walk(n.Else) {
					return true
				}
			}
		}
		return false
	}
	for _, nodes := range parsed {
		if walk(nodes) {
			return true
		}
	}
	return false
}

// collectUsedHelperNames returns the set of helper names (e.g. "upper", "lookup") used in the templates.
func collectUsedHelperNames(parsed map[string][]ast.Node, helperExprs map[string]string) map[string]bool {
	used := make(map[string]bool)
	builtinBlocks := map[string]bool{"if": true, "unless": true, "with": true, "each": true}

	var collectExpr func(parts []expr)
	collectExpr = func(parts []expr) {
		for _, p := range parts {
			switch p.kind {
			case exprPath:
				if helperExprs[p.value] != "" {
					used[p.value] = true
				}
			case exprCall:
				used[p.name] = true
				for _, a := range p.args {
					collectExpr([]expr{a})
				}
				for _, h := range p.hash {
					collectExpr([]expr{h.value})
				}
			}
		}
	}

	var walk func(nodes []ast.Node)
	walk = func(nodes []ast.Node) {
		for _, node := range nodes {
			switch n := node.(type) {
			case *ast.Mustache:
				parts, _, err := parseParts(n.Expr)
				if err == nil {
					collectExpr(parts)
				}
			case *ast.Block:
				if !builtinBlocks[n.Name] && helperExprs[n.Name] != "" {
					used[n.Name] = true
				}
				walk(n.Body)
				walk(n.Else)
			case *ast.Partial:
				parts, _, err := parseParts(n.Expr)
				if err == nil {
					collectExpr(parts)
				}
			}
		}
	}
	for _, nodes := range parsed {
		walk(nodes)
	}
	return used
}

// filterHelperImports keeps only imports for helpers that are actually used in the templates.
func filterHelperImports(imports []importSpec, helpers map[string]HelperRef, usedHelpers map[string]bool) []importSpec {
	neededPaths := make(map[string]bool)
	for name := range usedHelpers {
		if ref, ok := helpers[name]; ok && ref.ImportPath != "" {
			neededPaths[ref.ImportPath] = true
		}
	}
	out := make([]importSpec, 0, len(imports))
	for _, imp := range imports {
		if neededPaths[imp.path] {
			out = append(out, imp)
		}
	}
	return out
}

func sanitizeImportName(base string) string {
	if base == "" {
		return "pkg"
	}
	b := make([]byte, 0, len(base))
	for i := 0; i < len(base); i++ {
		ch := base[i]
		if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' {
			b = append(b, ch)
		} else {
			b = append(b, '_')
		}
	}
	if len(b) == 0 {
		return "pkg"
	}
	if b[0] >= '0' && b[0] <= '9' {
		b = append([]byte{'_'}, b...)
	}
	return string(b)
}

func uniqueAlias(base string, used map[string]bool) string {
	if base == "" {
		base = "pkg"
	}
	if !used[base] {
		return base
	}
	for i := 2; ; i++ {
		name := fmt.Sprintf("%s%d", base, i)
		if !used[name] {
			return name
		}
	}
}

// typedScope is one frame of the typed context stack (current variable and its type node).
type typedScope struct {
	varName    string
	pathPrefix string
	node       *typeNode
	eachKeyVar string // when in {{#each}} body, the loop key/index variable name for @key/@index
}

type generator struct {
	w           *codeWriter
	helpers     map[string]string
	partials    map[string]string
	tempID      int
	tree        *typeNode
	goName      string
	typedStack  []typedScope
	blocksVar   string   // non-empty when layout block/partial are used
	writerStack []string // when non-empty, currentWriter() returns "&" + top for partial body capture
}

func (g *generator) currentWriter() string {
	if len(g.writerStack) > 0 {
		return "&" + g.writerStack[len(g.writerStack)-1]
	}
	return "w"
}

func (g *generator) pushWriter(v string) {
	g.writerStack = append(g.writerStack, v)
}

func (g *generator) popWriter() {
	g.writerStack = g.writerStack[:len(g.writerStack)-1]
}

func (g *generator) emitNodes(nodes []ast.Node) error {
	for _, node := range nodes {
		switch n := node.(type) {
		case *ast.Text:
			if n.Value != "" {
				g.w.line("if _, err := io.WriteString(%s, %s); err != nil {", g.currentWriter(), strconv.Quote(n.Value))
				g.w.indentInc()
				g.w.line("return err")
				g.w.indentDec()
				g.w.line("}")
			}
		case *ast.Mustache:
			if err := g.emitMustache(n); err != nil {
				return err
			}
		case *ast.Partial:
			if err := g.emitPartial(n); err != nil {
				return err
			}
		case *ast.Block:
			if err := g.emitBlock(n); err != nil {
				return err
			}
		default:
			return hexerr.New(fmt.Sprintf("compiler: unsupported node %T", node))
		}
	}
	return nil
}

func (g *generator) emitBlock(n *ast.Block) error {
	switch n.Name {
	case "if":
		return g.emitIfBlock(n, false)
	case "unless":
		return g.emitIfBlock(n, true)
	case "with":
		return g.emitWithBlock(n)
	case "each":
		return g.emitEachBlock(n)
	case "block":
		return g.emitLayoutBlock(n)
	case "partial":
		return g.emitLayoutPartial(n)
	default:
		// Registered helper â†’ custom block helper
		if _, ok := g.helpers[n.Name]; ok {
			return g.emitCustomBlockHelper(n)
		}
		// Universal section: {{#anything}}...{{/anything}} => {{#with anything}}...{{/with}}
		// (Mustache/Handlebars semantics: lookup name in context; if truthy, render block with that value as context)
		sectionExpr := strings.TrimSpace(n.Args)
		if sectionExpr == "" {
			sectionExpr = n.Name
		}
		synthetic := &ast.Block{Name: "with", Args: sectionExpr, Body: n.Body, Else: n.Else, Params: n.Params}
		return g.emitWithBlock(synthetic)
	}
}

func (g *generator) emitMustache(n *ast.Mustache) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		if len(hash) > 0 {
			return hexerr.New("unexpected hash arguments")
		}
		return nil
	}
	if len(parts) == 1 {
		if parts[0].kind == exprPath {
			if helperExpr, ok := g.helpers[parts[0].value]; ok {
				return g.emitHelperOutput(helperExpr, nil, hash, n.Raw)
			}
		}
		if len(hash) > 0 {
			return hexerr.New("hash arguments require a helper")
		}
		valueExpr, err := g.emitExprValue(parts[0])
		if err != nil {
			return err
		}
		g.emitValueExpr(valueExpr, n.Raw)
		return nil
	}
	if parts[0].kind != exprPath {
		return hexerr.New("helper name must be a path")
	}
	helperExpr, ok := g.helpers[parts[0].value]
	if !ok {
		return hexerr.New(fmt.Sprintf("helper %q is not defined", parts[0].value))
	}
	return g.emitHelperOutput(helperExpr, parts[1:], hash, n.Raw)
}

func (g *generator) emitPartial(n *ast.Partial) error {
	parts, _, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return hexerr.New("partial invocation is empty")
	}
	if len(parts) > 2 {
		return hexerr.New("partial: context must be a single expression")
	}
	nameExpr := parts[0]
	scope, _ := g.currentTypedScope()
	partialCtxVar := scope.varName
	// Explicit context (e.g. {{> orderRow order}}): pass the given expression (row data).
	if len(parts) == 2 {
		valueExpr, err := g.emitExprValue(parts[1])
		if err != nil {
			return err
		}
		partialCtxVar = g.nextTemp("partialCtx")
		if valueExpr == "nil" {
			g.w.line("var %s any", partialCtxVar)
		} else {
			g.w.line("%s := %s", partialCtxVar, valueExpr)
		}
	}
	// Hash args (locals) not passed to partial in typed-context mode; omit to avoid unused variable

	writerArg := g.currentWriter()
	if nameExpr.kind == exprString {
		name := nameExpr.value
		goName, ok := g.partials[name]
		if !ok {
			return hexerr.New(fmt.Sprintf("partial %q is not defined", name))
		}
		// Explicit context: use partials map so any is accepted; partial keeps its own interface (e.g. OrderRowContext).
		if len(parts) == 2 {
			if g.blocksVar != "" {
				g.w.line("if err := partials[%q](%s, %s, %s); err != nil {", name, partialCtxVar, writerArg, g.blocksVar)
			} else {
				g.w.line("if err := partials[%q](%s, %s); err != nil {", name, partialCtxVar, writerArg)
			}
		} else {
			if g.blocksVar != "" {
				g.w.line("if err := render%s(%s, %s, %s); err != nil {", goName, partialCtxVar, writerArg, g.blocksVar)
			} else {
				g.w.line("if err := render%s(%s, %s); err != nil {", goName, partialCtxVar, writerArg)
			}
		}
		g.w.indentInc()
		g.w.line("return err")
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	if nameExpr.kind == exprPath {
		if goName, ok := g.partials[nameExpr.value]; ok {
			if len(parts) == 2 {
				if g.blocksVar != "" {
					g.w.line("if err := partials[%q](%s, %s, %s); err != nil {", nameExpr.value, partialCtxVar, writerArg, g.blocksVar)
				} else {
					g.w.line("if err := partials[%q](%s, %s); err != nil {", nameExpr.value, partialCtxVar, writerArg)
				}
			} else {
				if g.blocksVar != "" {
					g.w.line("if err := render%s(%s, %s, %s); err != nil {", goName, partialCtxVar, writerArg, g.blocksVar)
				} else {
					g.w.line("if err := render%s(%s, %s); err != nil {", goName, partialCtxVar, writerArg)
				}
			}
			g.w.indentInc()
			g.w.line("return err")
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		return hexerr.New(fmt.Sprintf("partial %q is not defined", nameExpr.value))
	}

	nameValue, err := g.emitExprValue(nameExpr)
	if err != nil {
		return err
	}
	nameVar := g.nextTemp("partial")
	g.w.line("%s := runtime.Stringify(%s)", nameVar, nameValue)
	g.w.line("partialFn, ok := partials[%s]", nameVar)
	g.w.line("if !ok {")
	g.w.indentInc()
	g.w.line("runtime.MissingPartialOutput(%s, %s)", writerArg, nameVar)
	g.w.indentDec()
	if g.blocksVar != "" {
		g.w.line("} else if err := partialFn(%s, %s, %s); err != nil {", partialCtxVar, writerArg, g.blocksVar)
	} else {
		g.w.line("} else if err := partialFn(%s, %s); err != nil {", partialCtxVar, writerArg)
	}
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitIfBlock(n *ast.Block, inverted bool) error {
	if len(n.Params) > 1 {
		return hexerr.New(fmt.Sprintf("block %q supports a single param", n.Name))
	}
	blockExpr, hash, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	useIncludeZero := hashHasIncludeZero(hash)
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	if valueExpr == "nil" {
		g.w.line("var %s any", valVar)
	} else {
		g.w.line("%s := %s", valVar, valueExpr)
	}
	if useIncludeZero {
		g.w.line("%s := runtime.IncludeZeroTruthy(%s)", condVar, valVar)
	} else {
		g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	}
	condExpr := condVar
	if inverted {
		condExpr = "!" + condVar
	}

	// Block param for if/unless: push typed scope so path resolves to the condition value
	var paramScopeNode *typeNode
	if len(n.Params) > 0 && blockExpr.kind == exprPath {
		scope, _ := g.currentTypedScope()
		paramScopeNode = nodeAtPath(scope.node, blockExpr.value)
	}

	g.w.line("if %s {", condExpr)
	g.w.indentInc()
	if len(n.Params) > 0 {
		if len(n.Params) > 1 {
			return hexerr.New(fmt.Sprintf("block %q supports a single param", n.Name))
		}
		paramVar := g.nextTemp("p")
		g.w.line("%s := %s", paramVar, valVar)
		g.pushTypedScope(paramVar, n.Params[0], paramScopeNode)
	}
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	if len(n.Params) > 0 {
		g.popTypedScope()
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitWithBlock(n *ast.Block) error {
	if len(n.Params) > 1 {
		return hexerr.New(fmt.Sprintf("block %q supports a single param", n.Name))
	}
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	scope, _ := g.currentTypedScope()
	pathStr := ""
	if blockExpr.kind == exprPath {
		pathStr = blockExpr.value
	}
	newPathPrefix := pathStr
	if scope.pathPrefix != "" {
		newPathPrefix = scope.pathPrefix + "." + pathStr
	}
	childNode := nodeAtPath(scope.node, pathStr)
	typedCtxVar := g.nextTemp("ctx")
	scopePathPrefix := newPathPrefix
	if len(n.Params) == 1 && isIdent(n.Params[0]) {
		typedCtxVar = n.Params[0]
		scopePathPrefix = n.Params[0] // so "u.name" resolves to current var + .Name()
	}
	if valueExpr == "nil" {
		g.w.line("var %s any", typedCtxVar)
	} else {
		g.w.line("%s := %s", typedCtxVar, valueExpr)
	}
	g.w.line("if runtime.IsTruthy(%s) {", typedCtxVar)
	g.w.indentInc()
	g.pushTypedScope(typedCtxVar, scopePathPrefix, childNode)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.popTypedScope()
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitEachBlock(n *ast.Block) error {
	if len(n.Params) > 2 {
		return hexerr.New(fmt.Sprintf("block %q supports up to 2 params", n.Name))
	}
	parts, _, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	var blockExpr expr
	if len(parts) == 2 && parts[0].kind == exprPath && parts[0].value == "in" {
		blockExpr = parts[1]
	} else if len(parts) != 1 {
		return hexerr.New(fmt.Sprintf("block %q requires a single expression", n.Name))
	} else {
		blockExpr = parts[0]
	}
	collectionExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	scope, _ := g.currentTypedScope()
	pathStr := ""
	if blockExpr.kind == exprPath {
		pathStr = blockExpr.value
	}
	colNode := nodeAtPath(scope.node, pathStr)
	var itemNode *typeNode
	if colNode != nil && colNode.isSlice && colNode.sliceElem != nil {
		itemNode = colNode.sliceElem
	}
	// Always use temps for loop vars to avoid "no new variables" in nested each
	itemVar := g.nextTemp("item")
	keyVar := g.nextTemp("key")
	itemsVar := g.nextTemp("items")
	rangeExpr := itemsVar
	lenExpr := itemsVar
	useMapAssert := false
	if collectionExpr == "nil" {
		// Unresolved path: use typed nil slice so we can range and use len
		itemType := contextItemInterfaceName(g.goName, pathStr)
		g.w.line("var %s []%s", itemsVar, itemType)
	} else {
		g.w.line("%s := %s", itemsVar, collectionExpr)
		// When collection is a map (object), use comma-ok so []any at runtime doesn't panic
		if colNode != nil && !colNode.isSlice {
			useMapAssert = true
		}
	}
	if useMapAssert {
		// Type tree says map; at runtime value may be []any (e.g. JSON array). Use comma-ok to avoid panic.
		mapVar := g.nextTemp("m")
		g.w.line("%s, _eachOk := %s.(map[string]any)", mapVar, itemsVar)
		g.w.line("if _eachOk && len(%s) > 0 {", mapVar)
		g.w.indentInc()
		g.w.line("for %s, %s := range %s {", keyVar, itemVar, mapVar)
		g.w.indentInc()
		g.w.line("_, _ = %s, %s", keyVar, itemVar)
		itemPathPrefix := pathStr
		if len(n.Params) > 0 {
			itemPathPrefix = n.Params[0]
		}
		g.pushTypedScope(itemVar, itemPathPrefix, itemNode)
		g.typedStack[len(g.typedStack)-1].eachKeyVar = keyVar
		if len(n.Params) > 1 {
			g.pushTypedScope(keyVar, n.Params[1], nil)
		}
		if err := g.emitNodes(n.Body); err != nil {
			return err
		}
		if len(n.Params) > 1 {
			g.popTypedScope()
		}
		g.popTypedScope()
		g.w.indentDec()
		g.w.line("}")
		g.w.indentDec()
		if len(n.Else) > 0 {
			g.w.line("} else {")
			g.w.indentInc()
			if err := g.emitNodes(n.Else); err != nil {
				return err
			}
			g.w.indentDec()
			g.w.line("}")
		}
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	g.w.line("if len(%s) > 0 {", lenExpr)
	g.w.indentInc()
	g.w.line("for %s, %s := range %s {", keyVar, itemVar, rangeExpr)
	g.w.indentInc()
	g.w.line("_, _ = %s, %s", keyVar, itemVar) // silence "declared and not used" when body uses @key/@index (we emit nil)
	itemPathPrefix := pathStr
	if len(n.Params) > 0 {
		itemPathPrefix = n.Params[0]
	}
	g.pushTypedScope(itemVar, itemPathPrefix, itemNode)
	g.typedStack[len(g.typedStack)-1].eachKeyVar = keyVar
	if len(n.Params) > 1 {
		g.pushTypedScope(keyVar, n.Params[1], nil)
	}
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	if len(n.Params) > 1 {
		g.popTypedScope()
	}
	g.popTypedScope()
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitCustomBlockHelper(n *ast.Block) error {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	helperExpr, ok := g.helpers[n.Name]
	if !ok {
		return hexerr.New(fmt.Sprintf("block helper %q is not defined", n.Name))
	}
	if len(parts) == 0 {
		return hexerr.New(fmt.Sprintf("block helper %q requires at least one argument", n.Name))
	}
	if parts[0].kind != exprPath {
		return hexerr.New("block helper name must be a path")
	}

	// Block body and inverse close over typed context; they receive only w.
	bodyFnVar := g.nextTemp("bodyFn")
	g.w.line("%s := func(w io.Writer) error {", bodyFnVar)
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.line("return nil")
	g.w.indentDec()
	g.w.line("}")

	inverseFnVar := "nil"
	if len(n.Else) > 0 {
		inverseFnVar = g.nextTemp("inverseFn")
		g.w.line("%s := func(w io.Writer) error {", inverseFnVar)
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.line("return nil")
		g.w.indentDec()
		g.w.line("}")
	}

	// Build options hash
	optionsVar := g.nextTemp("options")
	g.w.line("%s := runtime.BlockOptions{", optionsVar)
	g.w.indentInc()
	g.w.line("Fn: %s,", bodyFnVar)
	if inverseFnVar != "nil" {
		g.w.line("Inverse: %s,", inverseFnVar)
	}
	g.w.indentDec()
	g.w.line("}")

	// Prepare arguments: parts[0] is first arg, options appended later
	argsExpr, err := g.emitArgs(parts, hash)
	if err != nil {
		return err
	}
	// Append options to args
	if argsExpr == "nil" {
		argsExpr = g.nextTemp("args")
		g.w.line("%s := []any{%s}", argsExpr, optionsVar)
	} else {
		argsVar := g.nextTemp("args")
		g.w.line("%s := append(%s, %s)", argsVar, argsExpr, optionsVar)
		argsExpr = argsVar
	}

	// Call block helper; it receives full args (including BlockOptions) and uses GetBlockOptions internally
	hasOptsVar := g.nextTemp("hasOpts")
	g.w.line("_, %s := runtime.GetBlockOptions(%s)", hasOptsVar, argsExpr)
	g.w.line("if !%s {", hasOptsVar)
	g.w.indentInc()
	g.w.line("return fmt.Errorf(\"block helper %%q did not receive BlockOptions\", %q)", n.Name)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if err := %s(%s); err != nil {", helperExpr, argsExpr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitLayoutBlock(n *ast.Block) error {
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	if g.blocksVar == "" {
		return g.emitNodes(n.Body)
	}
	// blocks != nil: output registered content or default body
	if blockExpr.kind == exprString {
		name := blockExpr.value
		g.w.line("if %s != nil {", g.blocksVar)
		g.w.indentInc()
		g.w.line("if s, ok := %s.Get(%s); ok && s != \"\" {", g.blocksVar, strconv.Quote(name))
		g.w.indentInc()
		g.w.line("if _, err := io.WriteString(%s, s); err != nil { return err }", g.currentWriter())
		g.w.indentDec()
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Body); err != nil {
			return err
		}
		g.w.indentDec()
		g.w.line("}")
		g.w.indentDec()
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Body); err != nil {
			return err
		}
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	nameVar := g.nextTemp("blockName")
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	g.w.line("%s := runtime.Stringify(%s)", nameVar, valueExpr)
	g.w.line("if %s != nil {", g.blocksVar)
	g.w.indentInc()
	g.w.line("if s, ok := %s.Get(%s); ok && s != \"\" {", g.blocksVar, nameVar)
	g.w.indentInc()
	g.w.line("if _, err := io.WriteString(%s, s); err != nil { return err }", g.currentWriter())
	g.w.indentDec()
	g.w.line("} else {")
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	g.w.line("} else {")
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitLayoutPartial(n *ast.Block) error {
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	if g.blocksVar == "" {
		return g.emitNodes(n.Body)
	}
	// Capture body to buffer and register in blocks
	bufVar := g.nextTemp("buf")
	g.w.line("var %s strings.Builder", bufVar)
	g.pushWriter(bufVar)
	if err := g.emitNodes(n.Body); err != nil {
		g.popWriter()
		return err
	}
	g.popWriter()
	if blockExpr.kind == exprString {
		name := blockExpr.value
		g.w.line("if %s != nil { %s.Set(%s, %s.String()) }", g.blocksVar, g.blocksVar, strconv.Quote(name), bufVar)
		return nil
	}
	nameVar := g.nextTemp("blockName")
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	g.w.line("%s := runtime.Stringify(%s)", nameVar, valueExpr)
	g.w.line("if %s != nil { %s.Set(%s, %s.String()) }", g.blocksVar, g.blocksVar, nameVar, bufVar)
	return nil
}

func (g *generator) singleBlockExpr(n *ast.Block) (expr, []hashArg, error) {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return expr{}, nil, err
	}
	if len(parts) != 1 {
		return expr{}, nil, hexerr.New(fmt.Sprintf("block %q requires a single expression", n.Name))
	}
	return parts[0], hash, nil
}

// hashHasIncludeZero reports whether the hash contains includeZero=true.
// Used by {{#if}} / {{#unless}} to enable the includeZero custom extension.
func hashHasIncludeZero(hash []hashArg) bool {
	for _, h := range hash {
		if h.key == "includeZero" && h.value.kind == exprBool && h.value.value == "true" {
			return true
		}
	}
	return false
}

func (g *generator) emitValueExpr(expr string, raw bool) {
	if raw {
		g.writeValue("runtime.WriteRaw", expr)
		return
	}
	g.writeValue("runtime.WriteEscaped", expr)
}

func (g *generator) emitHelperOutput(helperExpr string, args []expr, hash []hashArg, raw bool) error {
	resultVar, err := g.emitHelperValue(helperExpr, args, hash)
	if err != nil {
		return err
	}
	g.emitValueExpr(resultVar, raw)
	return nil
}

func (g *generator) emitHelperValue(helperExpr string, args []expr, hash []hashArg) (string, error) {
	argsExpr, err := g.emitArgs(args, hash)
	if err != nil {
		return "", err
	}
	resultVar := g.nextTemp("result")
	g.w.line("%s, err := %s(%s)", resultVar, helperExpr, argsExpr)
	g.w.line("if err != nil {")
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return resultVar, nil
}

func (g *generator) emitArgs(args []expr, hash []hashArg) (string, error) {
	argExprs := make([]string, len(args))
	for i, arg := range args {
		var exprValue string
		if arg.kind == exprCall {
			helperExpr, ok := g.helpers[arg.name]
			if !ok {
				return "", hexerr.New(fmt.Sprintf("helper %q is not defined", arg.name))
			}
			var err error
			exprValue, err = g.emitHelperValue(helperExpr, arg.args, arg.hash)
			if err != nil {
				return "", err
			}
		} else {
			var err error
			exprValue, err = g.emitExprValue(arg)
			if err != nil {
				return "", err
			}
		}
		argExprs[i] = exprValue
	}
	if len(hash) > 0 {
		hashVar, err := g.emitHashMap(hash)
		if err != nil {
			return "", err
		}
		argExprs = append(argExprs, hashVar)
	}
	if len(argExprs) == 0 {
		return "nil", nil
	}
	argsVar := g.nextTemp("args")
	g.w.line("%s := []any{", argsVar)
	g.w.indentInc()
	for _, arg := range argExprs {
		g.w.line("%s,", arg)
	}
	g.w.indentDec()
	g.w.line("}")
	return argsVar, nil
}

type hashEntry struct {
	key   string
	value string
}

func (g *generator) emitHashMap(hash []hashArg) (string, error) {
	if len(hash) == 0 {
		return "nil", nil
	}
	entries := make([]hashEntry, 0, len(hash))
	for _, h := range hash {
		valueExpr, err := g.emitExprValue(h.value)
		if err != nil {
			return "", err
		}
		entries = append(entries, hashEntry{key: h.key, value: valueExpr})
	}
	hashVar := g.nextTemp("hash")
	g.w.line("%s := runtime.Hash{", hashVar)
	g.w.indentInc()
	for _, entry := range entries {
		g.w.line("%s: %s,", strconv.Quote(entry.key), entry.value)
	}
	g.w.indentDec()
	g.w.line("}")
	return hashVar, nil
}

func (g *generator) emitExprValue(value expr) (string, error) {
	if value.kind == exprCall {
		helperExpr, ok := g.helpers[value.name]
		if !ok {
			return "", hexerr.New(fmt.Sprintf("helper %q is not defined", value.name))
		}
		return g.emitHelperValue(helperExpr, value.args, value.hash)
	}
	// Inline literals directly instead of using EvalArg
	valueExpr, err := g.emitLiteralValue(value)
	if err != nil {
		return "", err
	}
	return valueExpr, nil
}

func (g *generator) emitLiteralValue(value expr) (string, error) {
	switch value.kind {
	case exprPath:
		return g.emitPathValue(value.value), nil
	case exprString:
		return strconv.Quote(value.value), nil
	case exprNumber:
		return formatNumberLiteral(value.value)
	case exprBool:
		return value.value, nil
	case exprNull:
		return "nil", nil
	default:
		return "", hexerr.New("invalid expression")
	}
}

func (g *generator) pushTypedScope(varName, pathPrefix string, node *typeNode) {
	g.typedStack = append(g.typedStack, typedScope{varName: varName, pathPrefix: pathPrefix, node: node})
}

func (g *generator) popTypedScope() {
	if len(g.typedStack) > 0 {
		g.typedStack = g.typedStack[:len(g.typedStack)-1]
	}
}

func (g *generator) currentTypedScope() (typedScope, bool) {
	if len(g.typedStack) == 0 {
		return typedScope{}, false
	}
	return g.typedStack[len(g.typedStack)-1], true
}

func (g *generator) emitPathValue(path string) string {
	path = strings.TrimSpace(path)
	// @index and @key: use the each loop's key variable (index for slice, key for map)
	if path == "@index" || path == "@key" {
		for i := len(g.typedStack) - 1; i >= 0; i-- {
			if g.typedStack[i].eachKeyVar != "" {
				return g.typedStack[i].eachKeyVar
			}
		}
		return "nil"
	}
	// Parent scope: "../path" or "../" - resolve rest against a parent scope (try each ancestor until one resolves)
	if path == ".." || strings.HasPrefix(path, "../") {
		rest := strings.TrimPrefix(path, "..")
		rest = strings.TrimPrefix(rest, "/")
		if len(g.typedStack) < 2 {
			return "nil"
		}
		for j := len(g.typedStack) - 2; j >= 0; j-- {
			parent := g.typedStack[j]
			if parent.node == nil {
				continue
			}
			if rest == "" {
				return parent.varName
			}
			chain, ok := resolvePathToMethodChain(parent.node, parent.pathPrefix, rest, g.goName)
			if !ok {
				continue
			}
			if chain == "" {
				return parent.varName
			}
			return parent.varName + "." + chain
		}
		return "nil"
	}
	// Resolve path: find scope where pathPrefix equals path or path starts with pathPrefix+"."
	// (e.g. "person.name" resolves from scope pathPrefix "person", not from top scope "idx")
	for i := len(g.typedStack) - 1; i >= 0; i-- {
		s := g.typedStack[i]
		if s.pathPrefix == path {
			return s.varName
		}
		if s.pathPrefix != "" && strings.HasPrefix(path, s.pathPrefix+".") && s.node != nil {
			chain, ok := resolvePathToMethodChain(s.node, s.pathPrefix, path, g.goName)
			if !ok {
				continue
			}
			if chain == "" {
				return s.varName
			}
			return s.varName + "." + chain
		}
	}
	scope, ok := g.currentTypedScope()
	if !ok || scope.node == nil {
		return "nil"
	}
	chain, ok := resolvePathToMethodChain(scope.node, scope.pathPrefix, path, g.goName)
	if !ok {
		return "nil"
	}
	if chain == "" {
		return scope.varName
	}
	return scope.varName + "." + chain
}

func (g *generator) writeValue(fn string, expr string) {
	g.w.line("if err := %s(w, %s); err != nil {", fn, expr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
}

func (g *generator) nextTemp(prefix string) string {
	g.tempID++
	return fmt.Sprintf("%s%d", prefix, g.tempID)
}

func formatNumberLiteral(value string) (string, error) {
	if strings.ContainsAny(value, ".eE") {
		f, err := strconv.ParseFloat(value, 64)
		if err != nil {
			return "", err
		}
		literal := strconv.FormatFloat(f, 'g', -1, 64)
		if !strings.ContainsAny(literal, ".eE") {
			literal += ".0"
		}
		return "float64(" + literal + ")", nil
	}
	if i, err := strconv.ParseInt(value, 10, 64); err == nil {
		return fmt.Sprintf("int64(%d)", i), nil
	}
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return "", err
	}
	literal := strconv.FormatFloat(f, 'g', -1, 64)
	if !strings.ContainsAny(literal, ".eE") {
		literal += ".0"
	}
	return "float64(" + literal + ")", nil
}

func isNumber(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}

type codeWriter struct {
	buf    bytes.Buffer
	indent int
}

func (w *codeWriter) indentInc() {
	w.indent++
}

func (w *codeWriter) indentDec() {
	if w.indent > 0 {
		w.indent--
	}
}

func (w *codeWriter) line(format string, args ...any) {
	fmt.Fprintf(&w.buf, format, args...)
	w.buf.WriteByte('\n')
}

func (w *codeWriter) String() string {
	return w.buf.String()
}

func goIdent(name string) string {
	if name == "" {
		return "Template"
	}
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	if len(parts) == 0 {
		return "Template"
	}
	var sb strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		sb.WriteString(capitalize(part))
	}
	out := sb.String()
	if out == "" || (out[0] >= '0' && out[0] <= '9') {
		return "Template" + out
	}
	return out
}

func capitalize(part string) string {
	if part == "" {
		return ""
	}
	b := []byte(part)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - 'a' + 'A'
	}
	return string(b)
}

func isIdent(value string) bool {
	if value == "" {
		return false
	}
	for i := 0; i < len(value); i++ {
		ch := value[i]
		if i == 0 {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_') {
				return false
			}
			continue
		}
		if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
			return false
		}
	}
	return true
}
