package compiler

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/andriyg76/go-hbars/internal/ast"
	"github.com/andriyg76/go-hbars/internal/parser"
)

// HelperRef points to a helper implementation.
type HelperRef struct {
	ImportPath string
	Ident      string
}

// Options configures code generation.
type Options struct {
	PackageName   string
	RuntimeImport string
	Helpers       map[string]HelperRef
}

// CompileTemplates compiles templates into Go source code.
func CompileTemplates(templates map[string]string, opts Options) ([]byte, error) {
	if opts.PackageName == "" {
		return nil, errors.New("compiler: package name is required")
	}
	runtimeImport := opts.RuntimeImport
	if runtimeImport == "" {
		runtimeImport = "github.com/andriyg76/go-hbars/runtime"
	}
	helperExprs, helperImports, err := prepareHelpers(opts.Helpers)
	if err != nil {
		return nil, err
	}

	names := make([]string, 0, len(templates))
	parsed := make(map[string][]ast.Node, len(templates))
	for name, tmpl := range templates {
		nodes, err := parser.Parse(tmpl)
		if err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		parsed[name] = nodes
		names = append(names, name)
	}
	sort.Strings(names)

	funcNames := make(map[string]string, len(names))
	seenFunc := make(map[string]string, len(names))
	for _, name := range names {
		ident := goIdent(name)
		if prev, exists := seenFunc[ident]; exists {
			return nil, fmt.Errorf("compiler: templates %q and %q map to %q", prev, name, ident)
		}
		seenFunc[ident] = name
		funcNames[name] = ident
	}

	w := &codeWriter{}
	w.line("// Code generated by hbc; DO NOT EDIT.")
	w.line("package %s", opts.PackageName)
	w.line("")
	w.line("import (")
	w.indentInc()
	w.line("%q", "io")
	w.line("%q", "strings")
	w.line("runtime %q", runtimeImport)
	for _, imp := range helperImports {
		if imp.name == "" {
			w.line("%q", imp.path)
		} else {
			w.line("%s %q", imp.name, imp.path)
		}
	}
	w.indentDec()
	w.line(")")
	w.line("")

	w.line("var partials map[string]func(*runtime.Context, io.Writer) error")
	w.line("")
	w.line("func init() {")
	w.indentInc()
	w.line("partials = map[string]func(*runtime.Context, io.Writer) error{")
	w.indentInc()
	for _, name := range names {
		w.line("%q: render%s,", name, funcNames[name])
	}
	w.indentDec()
	w.line("}")
	w.indentDec()
	w.line("}")
	w.line("")

	for _, name := range names {
		goName := funcNames[name]
		nodes := parsed[name]
		gen := &generator{w: w, helpers: helperExprs, partials: funcNames}
		w.line("func render%s(ctx *runtime.Context, w io.Writer) error {", goName)
		w.indentInc()
		if err := gen.emitNodes(nodes); err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		w.line("return nil")
		w.indentDec()
		w.line("}")
		w.line("")
		w.line("func Render%s(w io.Writer, data any) error {", goName)
		w.indentInc()
		w.line("ctx := runtime.NewContext(data)")
		w.line("return render%s(ctx, w)", goName)
		w.indentDec()
		w.line("}")
		w.line("")
		w.line("func Render%sString(data any) (string, error) {", goName)
		w.indentInc()
		w.line("var b strings.Builder")
		w.line("if err := Render%s(&b, data); err != nil {", goName)
		w.indentInc()
		w.line("return \"\", err")
		w.indentDec()
		w.line("}")
		w.line("return b.String(), nil")
		w.indentDec()
		w.line("}")
		w.line("")
	}

	formatted, err := format.Source([]byte(w.String()))
	if err != nil {
		return nil, fmt.Errorf("compiler: format: %w", err)
	}
	return formatted, nil
}

type importSpec struct {
	path string
	name string
}

func prepareHelpers(helpers map[string]HelperRef) (map[string]string, []importSpec, error) {
	helperExprs := make(map[string]string)
	if len(helpers) == 0 {
		return helperExprs, nil, nil
	}
	usedNames := map[string]bool{
		"io":      true,
		"strings": true,
		"runtime": true,
	}
	aliases := make(map[string]string)
	names := make([]string, 0, len(helpers))
	for name := range helpers {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		ref := helpers[name]
		if name == "" {
			return nil, nil, fmt.Errorf("compiler: helper name is empty")
		}
		if ref.Ident == "" {
			return nil, nil, fmt.Errorf("compiler: helper %q has empty identifier", name)
		}
		if ref.ImportPath == "" {
			helperExprs[name] = ref.Ident
			continue
		}
		if strings.Contains(ref.Ident, ".") || !isIdent(ref.Ident) {
			return nil, nil, fmt.Errorf("compiler: helper %q identifier %q must be a Go identifier", name, ref.Ident)
		}
		alias, ok := aliases[ref.ImportPath]
		if !ok {
			base := sanitizeImportName(path.Base(ref.ImportPath))
			alias = uniqueAlias(base, usedNames)
			aliases[ref.ImportPath] = alias
			usedNames[alias] = true
		}
		helperExprs[name] = alias + "." + ref.Ident
	}
	imports := make([]importSpec, 0, len(aliases))
	for importPath, alias := range aliases {
		imports = append(imports, importSpec{path: importPath, name: alias})
	}
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})
	return helperExprs, imports, nil
}

func sanitizeImportName(base string) string {
	if base == "" {
		return "pkg"
	}
	b := make([]byte, 0, len(base))
	for i := 0; i < len(base); i++ {
		ch := base[i]
		if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' {
			b = append(b, ch)
		} else {
			b = append(b, '_')
		}
	}
	if len(b) == 0 {
		return "pkg"
	}
	if b[0] >= '0' && b[0] <= '9' {
		b = append([]byte{'_'}, b...)
	}
	return string(b)
}

func uniqueAlias(base string, used map[string]bool) string {
	if base == "" {
		base = "pkg"
	}
	if !used[base] {
		return base
	}
	for i := 2; ; i++ {
		name := fmt.Sprintf("%s%d", base, i)
		if !used[name] {
			return name
		}
	}
}

type generator struct {
	w        *codeWriter
	helpers  map[string]string
	partials map[string]string
	tempID   int
}

func (g *generator) emitNodes(nodes []ast.Node) error {
	for _, node := range nodes {
		switch n := node.(type) {
		case *ast.Text:
			if n.Value != "" {
				g.w.line("if _, err := io.WriteString(w, %s); err != nil {", strconv.Quote(n.Value))
				g.w.indentInc()
				g.w.line("return err")
				g.w.indentDec()
				g.w.line("}")
			}
		case *ast.Mustache:
			if err := g.emitMustache(n); err != nil {
				return err
			}
		case *ast.Partial:
			if err := g.emitPartial(n); err != nil {
				return err
			}
		case *ast.Block:
			if err := g.emitBlock(n); err != nil {
				return err
			}
		case *ast.PartialBlock:
			if err := g.emitPartialBlock(n); err != nil {
				return err
			}
		default:
			return fmt.Errorf("compiler: unsupported node %T", node)
		}
	}
	return nil
}

func (g *generator) emitBlock(n *ast.Block) error {
	switch n.Name {
	case "if":
		return g.emitIfBlock(n, false)
	case "unless":
		return g.emitIfBlock(n, true)
	case "with":
		return g.emitWithBlock(n)
	case "each":
		return g.emitEachBlock(n)
	default:
		// Custom block helper
		return g.emitCustomBlockHelper(n)
	}
}

func (g *generator) emitMustache(n *ast.Mustache) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		if len(hash) > 0 {
			return fmt.Errorf("unexpected hash arguments")
		}
		return nil
	}
	if len(parts) == 1 {
		if parts[0].kind == exprPath {
			if helperExpr, ok := g.helpers[parts[0].value]; ok {
				return g.emitHelperOutput(helperExpr, nil, hash, n.Raw)
			}
		}
		if len(hash) > 0 {
			return fmt.Errorf("hash arguments require a helper")
		}
		valueExpr, err := g.emitExprValue(parts[0])
		if err != nil {
			return err
		}
		g.emitValueExpr(valueExpr, n.Raw)
		return nil
	}
	if parts[0].kind != exprPath {
		return fmt.Errorf("helper name must be a path")
	}
	helperExpr, ok := g.helpers[parts[0].value]
	if !ok {
		return fmt.Errorf("helper %q is not defined", parts[0].value)
	}
	return g.emitHelperOutput(helperExpr, parts[1:], hash, n.Raw)
}

func (g *generator) emitPartial(n *ast.Partial) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return fmt.Errorf("partial invocation is empty")
	}
	if len(parts) > 2 {
		return fmt.Errorf("partial: context must be a single expression")
	}
	nameExpr := parts[0]
	var ctxExpr expr
	hasCtx := false
	if len(parts) == 2 {
		ctxExpr = parts[1]
		hasCtx = true
	}
	localsVar := "nil"
	if len(hash) > 0 {
		localsVar, err = g.emitHashMap(hash)
		if err != nil {
			return err
		}
	}
	ctxVar := "ctx"
	if hasCtx {
		valueExpr, err := g.emitExprValue(ctxExpr)
		if err != nil {
			return err
		}
		valVar := g.nextTemp("val")
		g.w.line("%s := %s", valVar, valueExpr)
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(%s, %s, nil)", ctxVar, valVar, localsVar)
	} else if localsVar != "nil" {
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(ctx.Data, %s, nil)", ctxVar, localsVar)
	}

	if nameExpr.kind == exprString {
		name := nameExpr.value
		goName, ok := g.partials[name]
		if !ok {
			return fmt.Errorf("partial %q is not defined", name)
		}
		g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
		g.w.indentInc()
		g.w.line("return err")
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	if nameExpr.kind == exprPath {
		if goName, ok := g.partials[nameExpr.value]; ok {
			g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
			g.w.indentInc()
			g.w.line("return err")
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		return fmt.Errorf("partial %q is not defined", nameExpr.value)
	}

	nameValue, err := g.emitExprValue(nameExpr)
	if err != nil {
		return err
	}
	nameVar := g.nextTemp("partial")
	g.w.line("%s := runtime.Stringify(%s)", nameVar, nameValue)
	g.w.line("partialFn, ok := partials[%s]", nameVar)
	g.w.line("if !ok {")
	g.w.indentInc()
	g.w.line("return runtime.MissingPartial(%s)", nameVar)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if err := partialFn(%s, w); err != nil {", ctxVar)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitIfBlock(n *ast.Block, inverted bool) error {
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	condExpr := condVar
	if inverted {
		condExpr = "!" + condVar
	}
	
	// Support block params for if/unless
	localsVar := "nil"
	if len(n.Params) > 0 {
		if len(n.Params) > 1 {
			return fmt.Errorf("block %q supports a single param", n.Name)
		}
		localsVar = g.nextTemp("locals")
		g.w.line("%s := map[string]any{", localsVar)
		g.w.indentInc()
		g.w.line("%q: %s,", n.Params[0], valVar)
		g.w.indentDec()
		g.w.line("}")
	}
	
	g.w.line("if %s {", condExpr)
	g.w.indentInc()
	if len(n.Params) > 0 {
		g.w.line("ctx := ctx.WithScope(ctx.Data, %s, nil)", localsVar)
	}
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitWithBlock(n *ast.Block) error {
	if len(n.Params) > 1 {
		return fmt.Errorf("block %q supports a single param", n.Name)
	}
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	g.w.line("if %s {", condVar)
	g.w.indentInc()
	localsVar := "nil"
	if len(n.Params) == 1 {
		localsVar = g.nextTemp("locals")
		g.w.line("%s := map[string]any{", localsVar)
		g.w.indentInc()
		g.w.line("%q: %s,", n.Params[0], valVar)
		g.w.indentDec()
		g.w.line("}")
	}
	g.w.line("ctx := ctx.WithScope(%s, %s, nil)", valVar, localsVar)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitEachBlock(n *ast.Block) error {
	if len(n.Params) > 2 {
		return fmt.Errorf("block %q supports up to 2 params", n.Name)
	}
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	itemsVar := g.nextTemp("items")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.Iterate(%s)", itemsVar, valVar)
	g.w.line("if len(%s) > 0 {", itemsVar)
	g.w.indentInc()
	g.w.line("for i, item := range %s {", itemsVar)
	g.w.indentInc()
	dataVar := g.nextTemp("data")
	g.w.line("%s := map[string]any{", dataVar)
	g.w.indentInc()
	g.w.line("%q: item.Index,", "index")
	g.w.line("%q: i == 0,", "first")
	g.w.line("%q: i == len(%s)-1,", "last", itemsVar)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if item.Key != \"\" {")
	g.w.indentInc()
	g.w.line("%s[%q] = item.Key", dataVar, "key")
	g.w.indentDec()
	g.w.line("}")
	localsVar := "nil"
	if len(n.Params) > 0 {
		localsVar = g.nextTemp("locals")
		if len(n.Params) > 1 {
			keyVar := g.nextTemp("key")
			g.w.line("%s := any(item.Index)", keyVar)
			g.w.line("if item.Key != \"\" {")
			g.w.indentInc()
			g.w.line("%s = item.Key", keyVar)
			g.w.indentDec()
			g.w.line("}")
			g.w.line("%s := map[string]any{", localsVar)
			g.w.indentInc()
			g.w.line("%q: item.Value,", n.Params[0])
			g.w.line("%q: %s,", n.Params[1], keyVar)
			g.w.indentDec()
			g.w.line("}")
		} else {
			g.w.line("%s := map[string]any{", localsVar)
			g.w.indentInc()
			g.w.line("%q: item.Value,", n.Params[0])
			g.w.indentDec()
			g.w.line("}")
		}
	}
	g.w.line("ctx := ctx.WithScope(item.Value, %s, %s)", localsVar, dataVar)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitCustomBlockHelper(n *ast.Block) error {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return fmt.Errorf("block helper %q requires at least one argument", n.Name)
	}
	if parts[0].kind != exprPath {
		return fmt.Errorf("block helper name must be a path")
	}
	helperExpr, ok := g.helpers[parts[0].value]
	if !ok {
		return fmt.Errorf("block helper %q is not defined", parts[0].value)
	}
	
	// Emit block helper call
	// Block helpers receive: context, options with fn/inverse/fnElse
	// We need to create a function that renders the body
	bodyFnVar := g.nextTemp("bodyFn")
	g.w.line("%s := func(ctx *runtime.Context, w io.Writer) error {", bodyFnVar)
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.line("return nil")
	g.w.indentDec()
	g.w.line("}")
	
	inverseFnVar := "nil"
	if len(n.Else) > 0 {
		inverseFnVar = g.nextTemp("inverseFn")
		g.w.line("%s := func(ctx *runtime.Context, w io.Writer) error {", inverseFnVar)
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.line("return nil")
		g.w.indentDec()
		g.w.line("}")
	}
	
	// Build options hash
	optionsVar := g.nextTemp("options")
	g.w.line("%s := runtime.BlockOptions{", optionsVar)
	g.w.indentInc()
	g.w.line("Fn: %s,", bodyFnVar)
	if inverseFnVar != "nil" {
		g.w.line("Inverse: %s,", inverseFnVar)
	}
	g.w.indentDec()
	g.w.line("}")
	
	// Prepare arguments (block helpers receive options as last arg)
	argsExpr, err := g.emitArgs(parts[1:], hash)
	if err != nil {
		return err
	}
	// Append options to args
	if argsExpr == "nil" {
		argsExpr = g.nextTemp("args")
		g.w.line("%s := []any{%s}", argsExpr, optionsVar)
	} else {
		argsVar := g.nextTemp("args")
		g.w.line("%s := append(%s, %s)", argsVar, argsExpr, optionsVar)
		argsExpr = argsVar
	}
	
	// Call block helper (BlockHelper signature: func(ctx, args, options) error)
	// We need to extract options from args and call as BlockHelper
	optsVar := g.nextTemp("opts")
	g.w.line("%s, hasOpts := runtime.GetBlockOptions(%s)", optsVar, argsExpr)
	g.w.line("if !hasOpts {")
	g.w.indentInc()
	g.w.line("return fmt.Errorf(\"block helper %%q did not receive BlockOptions\", %q)", n.Name)
	g.w.indentDec()
	g.w.line("}")
	// Remove options from args for the helper call
	argsWithoutOpts := g.nextTemp("argsNoOpts")
	g.w.line("%s := %s[:len(%s)-1]", argsWithoutOpts, argsExpr, argsExpr)
	// For now, helpers that are used as blocks need to handle BlockOptions themselves
	// We pass options as last arg and helper should check for it
	// TODO: Support separate BlockHelper type registration
	g.w.line("if err := %s(ctx, %s); err != nil {", helperExpr, argsExpr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitPartialBlock(n *ast.PartialBlock) error {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return fmt.Errorf("partial block invocation is empty")
	}
	if len(parts) > 2 {
		return fmt.Errorf("partial block: context must be a single expression")
	}
	nameExpr := parts[0]
	var ctxExpr expr
	hasCtx := false
	if len(parts) == 2 {
		ctxExpr = parts[1]
		hasCtx = true
	}
	localsVar := "nil"
	if len(hash) > 0 {
		localsVar, err = g.emitHashMap(hash)
		if err != nil {
			return err
		}
	}
	ctxVar := "ctx"
	if hasCtx {
		valueExpr, err := g.emitExprValue(ctxExpr)
		if err != nil {
			return err
		}
		valVar := g.nextTemp("val")
		g.w.line("%s := %s", valVar, valueExpr)
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(%s, %s, nil)", ctxVar, valVar, localsVar)
	} else if localsVar != "nil" {
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(ctx.Data, %s, nil)", ctxVar, localsVar)
	}
	
	// Try to render partial, fallback to block content if not found
	if nameExpr.kind == exprString {
		name := nameExpr.value
		goName, ok := g.partials[name]
		if ok {
			// Partial exists, render it
			g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
			g.w.indentInc()
			g.w.line("return err")
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		// Partial doesn't exist, render fallback
		if err := g.emitNodes(n.Fallback); err != nil {
			return err
		}
		return nil
	}
	
	// Dynamic partial name
	nameValue, err := g.emitExprValue(nameExpr)
	if err != nil {
		return err
	}
	nameVar := g.nextTemp("partial")
	g.w.line("%s := runtime.Stringify(%s)", nameVar, nameValue)
	g.w.line("partialFn, ok := partials[%s]", nameVar)
	g.w.line("if ok {")
	g.w.indentInc()
	g.w.line("if err := partialFn(%s, w); err != nil {", ctxVar)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	g.w.line("} else {")
	g.w.indentInc()
	// Render fallback
	if err := g.emitNodes(n.Fallback); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) singleBlockExpr(n *ast.Block) (expr, []hashArg, error) {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return expr{}, nil, err
	}
	if len(parts) != 1 {
		return expr{}, nil, fmt.Errorf("block %q requires a single expression", n.Name)
	}
	return parts[0], hash, nil
}

func (g *generator) emitValueExpr(expr string, raw bool) {
	if raw {
		g.writeValue("runtime.WriteRaw", expr)
		return
	}
	g.writeValue("runtime.WriteEscaped", expr)
}

func (g *generator) emitHelperOutput(helperExpr string, args []expr, hash []hashArg, raw bool) error {
	resultVar, err := g.emitHelperValue(helperExpr, args, hash)
	if err != nil {
		return err
	}
	g.emitValueExpr(resultVar, raw)
	return nil
}

func (g *generator) emitHelperValue(helperExpr string, args []expr, hash []hashArg) (string, error) {
	argsExpr, err := g.emitArgs(args, hash)
	if err != nil {
		return "", err
	}
	resultVar := g.nextTemp("result")
	g.w.line("%s, err := %s(ctx, %s)", resultVar, helperExpr, argsExpr)
	g.w.line("if err != nil {")
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return resultVar, nil
}

func (g *generator) emitArgs(args []expr, hash []hashArg) (string, error) {
	argExprs := make([]string, len(args))
	for i, arg := range args {
		exprValue, err := g.emitExprValue(arg)
		if err != nil {
			return "", err
		}
		argExprs[i] = exprValue
	}
	if len(hash) > 0 {
		hashVar, err := g.emitHashMap(hash)
		if err != nil {
			return "", err
		}
		argExprs = append(argExprs, hashVar)
	}
	if len(argExprs) == 0 {
		return "nil", nil
	}
	argsVar := g.nextTemp("args")
	g.w.line("%s := []any{", argsVar)
	g.w.indentInc()
	for _, arg := range argExprs {
		g.w.line("%s,", arg)
	}
	g.w.indentDec()
	g.w.line("}")
	return argsVar, nil
}

func (g *generator) emitHashMap(hash []hashArg) (string, error) {
	if len(hash) == 0 {
		return "nil", nil
	}
	type entry struct {
		key   string
		value string
	}
	entries := make([]entry, 0, len(hash))
	for _, h := range hash {
		valueExpr, err := g.emitExprValue(h.value)
		if err != nil {
			return "", err
		}
		entries = append(entries, entry{key: h.key, value: valueExpr})
	}
	hashVar := g.nextTemp("hash")
	g.w.line("%s := runtime.Hash{", hashVar)
	g.w.indentInc()
	for _, entry := range entries {
		g.w.line("%s: %s,", strconv.Quote(entry.key), entry.value)
	}
	g.w.indentDec()
	g.w.line("}")
	return hashVar, nil
}

func (g *generator) emitExprValue(value expr) (string, error) {
	if value.kind == exprCall {
		helperExpr, ok := g.helpers[value.name]
		if !ok {
			return "", fmt.Errorf("helper %q is not defined", value.name)
		}
		return g.emitHelperValue(helperExpr, value.args, value.hash)
	}
	arg, err := argFromExpr(value)
	if err != nil {
		return "", err
	}
	return argExpr(arg), nil
}

func (g *generator) writeValue(fn string, expr string) {
	g.w.line("if err := %s(w, %s); err != nil {", fn, expr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
}

func (g *generator) nextTemp(prefix string) string {
	g.tempID++
	return fmt.Sprintf("%s%d", prefix, g.tempID)
}

type arg struct {
	kind  string
	value string
}

func argFromExpr(value expr) (arg, error) {
	switch value.kind {
	case exprPath:
		return arg{kind: "runtime.ArgPath", value: value.value}, nil
	case exprString:
		return arg{kind: "runtime.ArgString", value: value.value}, nil
	case exprNumber:
		return arg{kind: "runtime.ArgNumber", value: value.value}, nil
	case exprBool:
		return arg{kind: "runtime.ArgBool", value: value.value}, nil
	case exprNull:
		return arg{kind: "runtime.ArgNull", value: ""}, nil
	default:
		return arg{}, fmt.Errorf("invalid expression")
	}
}

func argExpr(arg arg) string {
	return fmt.Sprintf("runtime.EvalArg(ctx, %s, %s)", arg.kind, strconv.Quote(arg.value))
}

func isNumber(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}

type codeWriter struct {
	buf    bytes.Buffer
	indent int
}

func (w *codeWriter) indentInc() {
	w.indent++
}

func (w *codeWriter) indentDec() {
	if w.indent > 0 {
		w.indent--
	}
}

func (w *codeWriter) line(format string, args ...any) {
	fmt.Fprintf(&w.buf, format, args...)
	w.buf.WriteByte('\n')
}

func (w *codeWriter) String() string {
	return w.buf.String()
}

func goIdent(name string) string {
	if name == "" {
		return "Template"
	}
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	if len(parts) == 0 {
		return "Template"
	}
	var sb strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		sb.WriteString(capitalize(part))
	}
	out := sb.String()
	if out == "" || (out[0] >= '0' && out[0] <= '9') {
		return "Template" + out
	}
	return out
}

func capitalize(part string) string {
	if part == "" {
		return ""
	}
	b := []byte(part)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - 'a' + 'A'
	}
	return string(b)
}

func isIdent(value string) bool {
	if value == "" {
		return false
	}
	for i := 0; i < len(value); i++ {
		ch := value[i]
		if i == 0 {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_') {
				return false
			}
			continue
		}
		if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
			return false
		}
	}
	return true
}
