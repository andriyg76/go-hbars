package compiler

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/andriyg76/go-hbars/internal/ast"
	"github.com/andriyg76/go-hbars/internal/parser"
)

// HelperRef points to a helper implementation.
type HelperRef struct {
	ImportPath string
	Ident      string
}

// Options configures code generation.
type Options struct {
	PackageName   string
	RuntimeImport string
	Helpers       map[string]HelperRef
}

// CompileTemplates compiles templates into Go source code.
func CompileTemplates(templates map[string]string, opts Options) ([]byte, error) {
	if opts.PackageName == "" {
		return nil, errors.New("compiler: package name is required")
	}
	runtimeImport := opts.RuntimeImport
	if runtimeImport == "" {
		runtimeImport = "github.com/andriyg76/go-hbars/runtime"
	}
	helperExprs, helperImports, err := prepareHelpers(opts.Helpers)
	if err != nil {
		return nil, err
	}

	names := make([]string, 0, len(templates))
	parsed := make(map[string][]ast.Node, len(templates))
	for name, tmpl := range templates {
		nodes, err := parser.Parse(tmpl)
		if err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		parsed[name] = nodes
		names = append(names, name)
	}
	sort.Strings(names)

	funcNames := make(map[string]string, len(names))
	seenFunc := make(map[string]string, len(names))
	for _, name := range names {
		ident := goIdent(name)
		if prev, exists := seenFunc[ident]; exists {
			return nil, fmt.Errorf("compiler: templates %q and %q map to %q", prev, name, ident)
		}
		seenFunc[ident] = name
		funcNames[name] = ident
	}

	w := &codeWriter{}
	w.line("// Code generated by hbc; DO NOT EDIT.")
	w.line("package %s", opts.PackageName)
	w.line("")
	w.line("import (")
	w.indentInc()
	w.line("%q", "io")
	w.line("%q", "strings")
	w.line("runtime %q", runtimeImport)
	for _, imp := range helperImports {
		if imp.name == "" {
			w.line("%q", imp.path)
		} else {
			w.line("%s %q", imp.name, imp.path)
		}
	}
	w.indentDec()
	w.line(")")
	w.line("")

	for _, name := range names {
		goName := funcNames[name]
		nodes := parsed[name]
		gen := &generator{w: w, helpers: helperExprs, partials: funcNames}
		w.line("func render%s(ctx *runtime.Context, w io.Writer) error {", goName)
		w.indentInc()
		if err := gen.emitNodes(nodes); err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		w.line("return nil")
		w.indentDec()
		w.line("}")
		w.line("")
		w.line("func Render%s(w io.Writer, data any) error {", goName)
		w.indentInc()
		w.line("ctx := runtime.NewContext(data)")
		w.line("return render%s(ctx, w)", goName)
		w.indentDec()
		w.line("}")
		w.line("")
		w.line("func Render%sString(data any) (string, error) {", goName)
		w.indentInc()
		w.line("var b strings.Builder")
		w.line("if err := Render%s(&b, data); err != nil {", goName)
		w.indentInc()
		w.line("return \"\", err")
		w.indentDec()
		w.line("}")
		w.line("return b.String(), nil")
		w.indentDec()
		w.line("}")
		w.line("")
	}

	formatted, err := format.Source([]byte(w.String()))
	if err != nil {
		return nil, fmt.Errorf("compiler: format: %w", err)
	}
	return formatted, nil
}

type importSpec struct {
	path string
	name string
}

func prepareHelpers(helpers map[string]HelperRef) (map[string]string, []importSpec, error) {
	helperExprs := make(map[string]string)
	if len(helpers) == 0 {
		return helperExprs, nil, nil
	}
	usedNames := map[string]bool{
		"io":      true,
		"strings": true,
		"runtime": true,
	}
	aliases := make(map[string]string)
	names := make([]string, 0, len(helpers))
	for name := range helpers {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		ref := helpers[name]
		if name == "" {
			return nil, nil, fmt.Errorf("compiler: helper name is empty")
		}
		if ref.Ident == "" {
			return nil, nil, fmt.Errorf("compiler: helper %q has empty identifier", name)
		}
		if ref.ImportPath == "" {
			helperExprs[name] = ref.Ident
			continue
		}
		if strings.Contains(ref.Ident, ".") || !isIdent(ref.Ident) {
			return nil, nil, fmt.Errorf("compiler: helper %q identifier %q must be a Go identifier", name, ref.Ident)
		}
		alias, ok := aliases[ref.ImportPath]
		if !ok {
			base := sanitizeImportName(path.Base(ref.ImportPath))
			alias = uniqueAlias(base, usedNames)
			aliases[ref.ImportPath] = alias
			usedNames[alias] = true
		}
		helperExprs[name] = alias + "." + ref.Ident
	}
	imports := make([]importSpec, 0, len(aliases))
	for importPath, alias := range aliases {
		imports = append(imports, importSpec{path: importPath, name: alias})
	}
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})
	return helperExprs, imports, nil
}

func sanitizeImportName(base string) string {
	if base == "" {
		return "pkg"
	}
	b := make([]byte, 0, len(base))
	for i := 0; i < len(base); i++ {
		ch := base[i]
		if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' {
			b = append(b, ch)
		} else {
			b = append(b, '_')
		}
	}
	if len(b) == 0 {
		return "pkg"
	}
	if b[0] >= '0' && b[0] <= '9' {
		b = append([]byte{'_'}, b...)
	}
	return string(b)
}

func uniqueAlias(base string, used map[string]bool) string {
	if base == "" {
		base = "pkg"
	}
	if !used[base] {
		return base
	}
	for i := 2; ; i++ {
		name := fmt.Sprintf("%s%d", base, i)
		if !used[name] {
			return name
		}
	}
}

type generator struct {
	w        *codeWriter
	helpers  map[string]string
	partials map[string]string
	tempID   int
}

func (g *generator) emitNodes(nodes []ast.Node) error {
	for _, node := range nodes {
		switch n := node.(type) {
		case *ast.Text:
			if n.Value != "" {
				g.w.line("if _, err := io.WriteString(w, %s); err != nil {", strconv.Quote(n.Value))
				g.w.indentInc()
				g.w.line("return err")
				g.w.indentDec()
				g.w.line("}")
			}
		case *ast.Mustache:
			if err := g.emitMustache(n); err != nil {
				return err
			}
		case *ast.Partial:
			if err := g.emitPartial(n); err != nil {
				return err
			}
		case *ast.Block:
			if err := g.emitBlock(n); err != nil {
				return err
			}
		default:
			return fmt.Errorf("compiler: unsupported node %T", node)
		}
	}
	return nil
}

func (g *generator) emitBlock(n *ast.Block) error {
	switch n.Name {
	case "if":
		return g.emitIfBlock(n, false)
	case "unless":
		return g.emitIfBlock(n, true)
	case "with":
		return g.emitWithBlock(n)
	case "each":
		return g.emitEachBlock(n)
	default:
		return fmt.Errorf("block helper %q is not implemented", n.Name)
	}
}

func (g *generator) emitMustache(n *ast.Mustache) error {
	tokens, err := splitArgs(n.Expr)
	if err != nil {
		return err
	}
	if len(tokens) == 0 {
		return nil
	}
	if len(tokens) == 1 {
		arg, err := classifyToken(tokens[0])
		if err != nil {
			return err
		}
		if arg.kind != "runtime.ArgPath" {
			g.emitValue(arg, n.Raw)
			return nil
		}
		name := tokens[0].value
		if helperExpr, ok := g.helpers[name]; ok {
			g.emitHelperCall(helperExpr, nil, n.Raw)
			return nil
		}
		g.emitValue(arg, n.Raw)
		return nil
	}
	name := tokens[0].value
	helperExpr, ok := g.helpers[name]
	if !ok {
		return fmt.Errorf("helper %q is not defined", name)
	}
	args := make([]arg, 0, len(tokens)-1)
	for _, tok := range tokens[1:] {
		arg, err := classifyToken(tok)
		if err != nil {
			return err
		}
		args = append(args, arg)
	}
	g.emitHelperCall(helperExpr, args, n.Raw)
	return nil
}

func (g *generator) emitPartial(n *ast.Partial) error {
	goName, ok := g.partials[n.Name]
	if !ok {
		return fmt.Errorf("partial %q is not defined", n.Name)
	}
	ctxVar := "ctx"
	if n.ContextExpr != "" {
		tokens, err := splitArgs(n.ContextExpr)
		if err != nil {
			return err
		}
		if len(tokens) != 1 {
			return fmt.Errorf("partial %q: context must be a single expression", n.Name)
		}
		arg, err := classifyToken(tokens[0])
		if err != nil {
			return err
		}
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithData(%s)", ctxVar, argExpr(arg))
	}
	g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitIfBlock(n *ast.Block, inverted bool) error {
	arg, err := g.singleBlockArg(n)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, argExpr(arg))
	g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	condExpr := condVar
	if inverted {
		condExpr = "!" + condVar
	}
	g.w.line("if %s {", condExpr)
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitWithBlock(n *ast.Block) error {
	arg, err := g.singleBlockArg(n)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, argExpr(arg))
	g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	g.w.line("if %s {", condVar)
	g.w.indentInc()
	g.w.line("ctx := ctx.WithData(%s)", valVar)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitEachBlock(n *ast.Block) error {
	arg, err := g.singleBlockArg(n)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	itemsVar := g.nextTemp("items")
	g.w.line("%s := %s", valVar, argExpr(arg))
	g.w.line("%s := runtime.Iterate(%s)", itemsVar, valVar)
	g.w.line("if len(%s) > 0 {", itemsVar)
	g.w.indentInc()
	g.w.line("for _, item := range %s {", itemsVar)
	g.w.indentInc()
	g.w.line("ctx := ctx.WithData(item)")
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) singleBlockArg(n *ast.Block) (arg, error) {
	tokens, err := splitArgs(n.Args)
	if err != nil {
		return arg{}, err
	}
	if len(tokens) != 1 {
		return arg{}, fmt.Errorf("block %q requires a single expression", n.Name)
	}
	return classifyToken(tokens[0])
}

func (g *generator) emitValue(arg arg, raw bool) {
	if raw {
		g.writeValue("runtime.WriteRaw", argExpr(arg))
		return
	}
	g.writeValue("runtime.WriteEscaped", argExpr(arg))
}

func (g *generator) emitHelperCall(helperExpr string, args []arg, raw bool) {
	argsExpr := "nil"
	if len(args) > 0 {
		argsVar := g.nextTemp("args")
		g.w.line("%s := []any{", argsVar)
		g.w.indentInc()
		for _, arg := range args {
			g.w.line("%s,", argExpr(arg))
		}
		g.w.indentDec()
		g.w.line("}")
		argsExpr = argsVar
	}
	resultVar := g.nextTemp("result")
	g.w.line("%s, err := %s(ctx, %s)", resultVar, helperExpr, argsExpr)
	g.w.line("if err != nil {")
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	if raw {
		g.writeValue("runtime.WriteRaw", resultVar)
		return
	}
	g.writeValue("runtime.WriteEscaped", resultVar)
}

func (g *generator) writeValue(fn string, expr string) {
	g.w.line("if err := %s(w, %s); err != nil {", fn, expr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
}

func (g *generator) nextTemp(prefix string) string {
	g.tempID++
	return fmt.Sprintf("%s%d", prefix, g.tempID)
}

type arg struct {
	kind  string
	value string
}

func classifyToken(tok token) (arg, error) {
	if tok.quoted {
		return arg{kind: "runtime.ArgString", value: tok.value}, nil
	}
	lower := strings.ToLower(tok.value)
	switch lower {
	case "true", "false":
		return arg{kind: "runtime.ArgBool", value: lower}, nil
	case "null", "nil":
		return arg{kind: "runtime.ArgNull", value: ""}, nil
	default:
		if isNumber(tok.value) {
			return arg{kind: "runtime.ArgNumber", value: tok.value}, nil
		}
		return arg{kind: "runtime.ArgPath", value: tok.value}, nil
	}
}

func argExpr(arg arg) string {
	return fmt.Sprintf("runtime.EvalArg(ctx, %s, %s)", arg.kind, strconv.Quote(arg.value))
}

func isNumber(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

type token struct {
	value  string
	quoted bool
}

func splitArgs(input string) ([]token, error) {
	var tokens []token
	for i := 0; i < len(input); {
		for i < len(input) && isSpace(input[i]) {
			i++
		}
		if i >= len(input) {
			break
		}
		switch input[i] {
		case '"', '\'':
			quote := input[i]
			i++
			var sb strings.Builder
			closed := false
			for i < len(input) {
				ch := input[i]
				if ch == '\\' && i+1 < len(input) {
					next := input[i+1]
					if next == quote || next == '\\' {
						sb.WriteByte(next)
						i += 2
						continue
					}
				}
				if ch == quote {
					i++
					closed = true
					break
				}
				sb.WriteByte(ch)
				i++
			}
			if !closed {
				return nil, fmt.Errorf("unclosed string literal")
			}
			tokens = append(tokens, token{value: sb.String(), quoted: true})
		default:
			start := i
			for i < len(input) && !isSpace(input[i]) {
				i++
			}
			tokens = append(tokens, token{value: input[start:i]})
		}
	}
	return tokens, nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}

type codeWriter struct {
	buf    bytes.Buffer
	indent int
}

func (w *codeWriter) indentInc() {
	w.indent++
}

func (w *codeWriter) indentDec() {
	if w.indent > 0 {
		w.indent--
	}
}

func (w *codeWriter) line(format string, args ...any) {
	fmt.Fprintf(&w.buf, format, args...)
	w.buf.WriteByte('\n')
}

func (w *codeWriter) String() string {
	return w.buf.String()
}

func goIdent(name string) string {
	if name == "" {
		return "Template"
	}
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	if len(parts) == 0 {
		return "Template"
	}
	var sb strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		sb.WriteString(capitalize(part))
	}
	out := sb.String()
	if out == "" || (out[0] >= '0' && out[0] <= '9') {
		return "Template" + out
	}
	return out
}

func capitalize(part string) string {
	if part == "" {
		return ""
	}
	b := []byte(part)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - 'a' + 'A'
	}
	return string(b)
}

func isIdent(value string) bool {
	if value == "" {
		return false
	}
	for i := 0; i < len(value); i++ {
		ch := value[i]
		if i == 0 {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_') {
				return false
			}
			continue
		}
		if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
			return false
		}
	}
	return true
}
