package compiler

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/andriyg76/go-hbars/internal/ast"
	"github.com/andriyg76/go-hbars/internal/parser"
	"github.com/andriyg76/hexerr"
)

// HelperRef points to a helper implementation.
type HelperRef struct {
	ImportPath string
	Ident      string
}

// Options configures code generation.
type Options struct {
	PackageName       string
	RuntimeImport     string
	Helpers           map[string]HelperRef
	GenerateBootstrap bool // Generate bootstrap code for server/processor
}

// CompileTemplates compiles templates into Go source code.
func CompileTemplates(templates map[string]string, opts Options) ([]byte, error) {
	if opts.PackageName == "" {
		return nil, hexerr.New("compiler: package name is required")
	}
	runtimeImport := opts.RuntimeImport
	if runtimeImport == "" {
		runtimeImport = "github.com/andriyg76/go-hbars/runtime"
	}
	helperExprs, helperImports, err := prepareHelpers(opts.Helpers, runtimeImport)
	if err != nil {
		return nil, err
	}

	names := make([]string, 0, len(templates))
	parsed := make(map[string][]ast.Node, len(templates))
	for name, tmpl := range templates {
		nodes, err := parser.Parse(tmpl)
		if err != nil {
			return nil, hexerr.Wrapf(err, "compiler: template %q", name)
		}
		parsed[name] = nodes
		names = append(names, name)
	}
	sort.Strings(names)

	funcNames := make(map[string]string, len(names))
	seenFunc := make(map[string]string, len(names))
	for _, name := range names {
		ident := goIdent(name)
		if prev, exists := seenFunc[ident]; exists {
			return nil, hexerr.New(fmt.Sprintf("compiler: templates %q and %q map to %q", prev, name, ident))
		}
		seenFunc[ident] = name
		funcNames[name] = ident
	}

	needFmt := templatesUseBlockHelpers(parsed, helperExprs)
	header := &codeWriter{}
	header.line("// Code generated by hbc; DO NOT EDIT.")
	header.line("package %s", opts.PackageName)
	header.line("")
	header.line("import (")
	header.indentInc()
	if needFmt {
		header.line("%q", "fmt")
	}
	header.line("%q", "io")
	header.line("%q", "strings")
	header.line("runtime %q", runtimeImport)
	for _, imp := range helperImports {
		if imp.name == "" {
			header.line("%q", imp.path)
		} else {
			header.line("%s %q", imp.name, imp.path)
		}
	}
	if opts.GenerateBootstrap {
		header.line("%q", "github.com/andriyg76/go-hbars/internal/processor")
		header.line("%q", "github.com/andriyg76/go-hbars/pkg/sitegen")
	}
	header.indentDec()
	header.line(")")
	header.line("")

	contextIfaces := &codeWriter{}
	for _, name := range names {
		col := newPathCollector(helperExprs)
		if err := col.collectNodes(parsed[name]); err != nil {
			return nil, hexerr.Wrapf(err, "compiler: template %q context inference", name)
		}
		tree := buildTypeTree(col.paths, col.eachFields)
		emitContextInterfaces(contextIfaces, name, tree)
	}

	partials := &codeWriter{}
	partials.line("var partials map[string]func(*runtime.Context, io.Writer) error")
	partials.line("")
	partials.line("func init() {")
	partials.indentInc()
	partials.line("partials = map[string]func(*runtime.Context, io.Writer) error{")
	partials.indentInc()
	for _, name := range names {
		partials.line("%q: render%s,", name, funcNames[name])
	}
	partials.indentDec()
	partials.line("}")
	partials.indentDec()
	partials.line("}")
	partials.line("")

	functions := &codeWriter{}
	for _, name := range names {
		goName := funcNames[name]
		nodes := parsed[name]
		gen := &generator{w: functions, helpers: helperExprs, partials: funcNames}
		functions.line("func render%s(ctx *runtime.Context, w io.Writer) error {", goName)
		functions.indentInc()
		functions.line("ctx.Output = w")
		if err := gen.emitNodes(nodes); err != nil {
			return nil, hexerr.Wrapf(err, "compiler: template %q", name)
		}
		functions.line("return nil")
		functions.indentDec()
		functions.line("}")
		functions.line("")
		functions.line("func Render%s(w io.Writer, data any) error {", goName)
		functions.indentInc()
		functions.line("ctx := runtime.NewContext(data)")
		functions.line("return render%s(ctx, w)", goName)
		functions.indentDec()
		functions.line("}")
		functions.line("")
		functions.line("func Render%sString(data any) (string, error) {", goName)
		functions.indentInc()
		functions.line("var b strings.Builder")
		functions.line("if err := Render%s(&b, data); err != nil {", goName)
		functions.indentInc()
		functions.line("return \"\", err")
		functions.indentDec()
		functions.line("}")
		functions.line("return b.String(), nil")
		functions.indentDec()
		functions.line("}")
		functions.line("")
	}

	// Generate bootstrap code if requested
	bootstrap := &codeWriter{}
	if opts.GenerateBootstrap {
		generateBootstrapCode(bootstrap, names, funcNames)
	}

	var out strings.Builder
	out.WriteString(header.String())
	out.WriteString(contextIfaces.String())
	out.WriteString(partials.String())
	out.WriteString(functions.String())
	if bootstrap.String() != "" {
		out.WriteString(bootstrap.String())
	}

	formatted, err := format.Source([]byte(out.String()))
	if err != nil {
		return nil, hexerr.Wrapf(err, "compiler: format")
	}
	return formatted, nil
}

type importSpec struct {
	path string
	name string
}

func prepareHelpers(helpers map[string]HelperRef, runtimeImport string) (map[string]string, []importSpec, error) {
	helperExprs := make(map[string]string)
	if len(helpers) == 0 {
		return helperExprs, nil, nil
	}
	usedNames := map[string]bool{
		"io":      true,
		"strings": true,
		"runtime": true,
	}
	aliases := make(map[string]string)
	names := make([]string, 0, len(helpers))
	for name := range helpers {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		ref := helpers[name]
		if name == "" {
			return nil, nil, hexerr.New("compiler: helper name is empty")
		}
		if ref.Ident == "" {
			return nil, nil, hexerr.New(fmt.Sprintf("compiler: helper %q has empty identifier", name))
		}
		if ref.ImportPath == "" {
			helperExprs[name] = ref.Ident
			continue
		}
		if strings.Contains(ref.Ident, ".") || !isIdent(ref.Ident) {
			return nil, nil, hexerr.New(fmt.Sprintf("compiler: helper %q identifier %q must be a Go identifier", name, ref.Ident))
		}
		if runtimeImport != "" && ref.ImportPath == runtimeImport {
			helperExprs[name] = "runtime." + ref.Ident
			continue
		}
		alias, ok := aliases[ref.ImportPath]
		if !ok {
			base := sanitizeImportName(path.Base(ref.ImportPath))
			alias = uniqueAlias(base, usedNames)
			aliases[ref.ImportPath] = alias
			usedNames[alias] = true
		}
		helperExprs[name] = alias + "." + ref.Ident
	}
	imports := make([]importSpec, 0, len(aliases))
	for importPath, alias := range aliases {
		imports = append(imports, importSpec{path: importPath, name: alias})
	}
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})
	return helperExprs, imports, nil
}

func templatesUseBlockHelpers(parsed map[string][]ast.Node, helperExprs map[string]string) bool {
	builtinBlocks := map[string]bool{"if": true, "unless": true, "with": true, "each": true}
	var walk func(nodes []ast.Node) bool
	walk = func(nodes []ast.Node) bool {
		for _, node := range nodes {
			switch n := node.(type) {
			case *ast.Block:
				if !builtinBlocks[n.Name] && helperExprs[n.Name] != "" {
					return true
				}
				if walk(n.Body) || walk(n.Else) {
					return true
				}
			}
		}
		return false
	}
	for _, nodes := range parsed {
		if walk(nodes) {
			return true
		}
	}
	return false
}

func sanitizeImportName(base string) string {
	if base == "" {
		return "pkg"
	}
	b := make([]byte, 0, len(base))
	for i := 0; i < len(base); i++ {
		ch := base[i]
		if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' {
			b = append(b, ch)
		} else {
			b = append(b, '_')
		}
	}
	if len(b) == 0 {
		return "pkg"
	}
	if b[0] >= '0' && b[0] <= '9' {
		b = append([]byte{'_'}, b...)
	}
	return string(b)
}

func uniqueAlias(base string, used map[string]bool) string {
	if base == "" {
		base = "pkg"
	}
	if !used[base] {
		return base
	}
	for i := 2; ; i++ {
		name := fmt.Sprintf("%s%d", base, i)
		if !used[name] {
			return name
		}
	}
}

type generator struct {
	w        *codeWriter
	helpers  map[string]string
	partials map[string]string
	tempID   int
}

func (g *generator) emitNodes(nodes []ast.Node) error {
	for _, node := range nodes {
		switch n := node.(type) {
		case *ast.Text:
			if n.Value != "" {
				g.w.line("if _, err := io.WriteString(w, %s); err != nil {", strconv.Quote(n.Value))
				g.w.indentInc()
				g.w.line("return err")
				g.w.indentDec()
				g.w.line("}")
			}
		case *ast.Mustache:
			if err := g.emitMustache(n); err != nil {
				return err
			}
		case *ast.Partial:
			if err := g.emitPartial(n); err != nil {
				return err
			}
		case *ast.Block:
			if err := g.emitBlock(n); err != nil {
				return err
			}
		default:
			return hexerr.New(fmt.Sprintf("compiler: unsupported node %T", node))
		}
	}
	return nil
}

func (g *generator) emitBlock(n *ast.Block) error {
	switch n.Name {
	case "if":
		return g.emitIfBlock(n, false)
	case "unless":
		return g.emitIfBlock(n, true)
	case "with":
		return g.emitWithBlock(n)
	case "each":
		return g.emitEachBlock(n)
	default:
		// Registered helper â†’ custom block helper
		if _, ok := g.helpers[n.Name]; ok {
			return g.emitCustomBlockHelper(n)
		}
		// Universal section: {{#anything}}...{{/anything}} => {{#with anything}}...{{/with}}
		// (Mustache/Handlebars semantics: lookup name in context; if truthy, render block with that value as context)
		sectionExpr := strings.TrimSpace(n.Args)
		if sectionExpr == "" {
			sectionExpr = n.Name
		}
		synthetic := &ast.Block{Name: "with", Args: sectionExpr, Body: n.Body, Else: n.Else, Params: n.Params}
		return g.emitWithBlock(synthetic)
	}
}

func (g *generator) emitMustache(n *ast.Mustache) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		if len(hash) > 0 {
			return hexerr.New("unexpected hash arguments")
		}
		return nil
	}
	if len(parts) == 1 {
		if parts[0].kind == exprPath {
			if helperExpr, ok := g.helpers[parts[0].value]; ok {
				return g.emitHelperOutput(helperExpr, nil, hash, n.Raw)
			}
		}
		if len(hash) > 0 {
			return hexerr.New("hash arguments require a helper")
		}
		valueExpr, err := g.emitExprValue(parts[0])
		if err != nil {
			return err
		}
		g.emitValueExpr(valueExpr, n.Raw)
		return nil
	}
	if parts[0].kind != exprPath {
		return hexerr.New("helper name must be a path")
	}
	helperExpr, ok := g.helpers[parts[0].value]
	if !ok {
		return hexerr.New(fmt.Sprintf("helper %q is not defined", parts[0].value))
	}
	return g.emitHelperOutput(helperExpr, parts[1:], hash, n.Raw)
}

func (g *generator) emitPartial(n *ast.Partial) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return hexerr.New("partial invocation is empty")
	}
	if len(parts) > 2 {
		return hexerr.New("partial: context must be a single expression")
	}
	nameExpr := parts[0]
	var ctxExpr expr
	hasCtx := false
	if len(parts) == 2 {
		ctxExpr = parts[1]
		hasCtx = true
	}
	localsVar := "nil"
	if len(hash) > 0 {
		localsVar, err = g.emitHashMap(hash)
		if err != nil {
			return err
		}
	}
	ctxVar := "ctx"
	if hasCtx {
		valueExpr, err := g.emitExprValue(ctxExpr)
		if err != nil {
			return err
		}
		valVar := g.nextTemp("val")
		g.w.line("%s := %s", valVar, valueExpr)
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(%s, %s, nil)", ctxVar, valVar, localsVar)
	} else if localsVar != "nil" {
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(ctx.Data, %s, nil)", ctxVar, localsVar)
	}

	if nameExpr.kind == exprString {
		name := nameExpr.value
		goName, ok := g.partials[name]
		if !ok {
			return hexerr.New(fmt.Sprintf("partial %q is not defined", name))
		}
		g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
		g.w.indentInc()
		g.w.line("return err")
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	if nameExpr.kind == exprPath {
		if goName, ok := g.partials[nameExpr.value]; ok {
			g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
			g.w.indentInc()
			g.w.line("return err")
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		return hexerr.New(fmt.Sprintf("partial %q is not defined", nameExpr.value))
	}

	nameValue, err := g.emitExprValue(nameExpr)
	if err != nil {
		return err
	}
	nameVar := g.nextTemp("partial")
	g.w.line("%s := runtime.Stringify(%s)", nameVar, nameValue)
	g.w.line("partialFn, ok := partials[%s]", nameVar)
	g.w.line("if !ok {")
	g.w.indentInc()
	g.w.line("return runtime.MissingPartial(%s)", nameVar)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if err := partialFn(%s, w); err != nil {", ctxVar)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitIfBlock(n *ast.Block, inverted bool) error {
	if len(n.Params) > 1 {
		return hexerr.New(fmt.Sprintf("block %q supports a single param", n.Name))
	}
	blockExpr, hash, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	useIncludeZero := hashHasIncludeZero(hash)
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, valueExpr)
	if useIncludeZero {
		g.w.line("%s := runtime.IncludeZeroTruthy(%s)", condVar, valVar)
	} else {
		g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	}
	condExpr := condVar
	if inverted {
		condExpr = "!" + condVar
	}

	// Support block params for if/unless
	localsVar := "nil"
	if len(n.Params) > 0 {
		if len(n.Params) > 1 {
			return hexerr.New(fmt.Sprintf("block %q supports a single param", n.Name))
		}
		localsVar = g.nextTemp("locals")
		g.w.line("%s := map[string]any{", localsVar)
		g.w.indentInc()
		g.w.line("%q: %s,", n.Params[0], valVar)
		g.w.indentDec()
		g.w.line("}")
	}

	g.w.line("if %s {", condExpr)
	g.w.indentInc()
	if len(n.Params) > 0 {
		g.w.line("ctx := ctx.WithScope(ctx.Data, %s, nil)", localsVar)
	}
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitWithBlock(n *ast.Block) error {
	if len(n.Params) > 1 {
		return hexerr.New(fmt.Sprintf("block %q supports a single param", n.Name))
	}
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	g.w.line("if %s {", condVar)
	g.w.indentInc()
	localsVar := "nil"
	if len(n.Params) == 1 {
		localsVar = g.nextTemp("locals")
		g.w.line("%s := map[string]any{", localsVar)
		g.w.indentInc()
		g.w.line("%q: %s,", n.Params[0], valVar)
		g.w.indentDec()
		g.w.line("}")
	}
	g.w.line("ctx := ctx.WithScope(%s, %s, nil)", valVar, localsVar)
	g.w.line("_ = ctx // scope for body, may be unused when body is literal-only")
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitEachBlock(n *ast.Block) error {
	if len(n.Params) > 2 {
		return hexerr.New(fmt.Sprintf("block %q supports up to 2 params", n.Name))
	}
	// Accept "each in collection" as synonym for "each collection"
	parts, _, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	var blockExpr expr
	if len(parts) == 2 && parts[0].kind == exprPath && parts[0].value == "in" {
		blockExpr = parts[1]
	} else if len(parts) != 1 {
		return hexerr.New(fmt.Sprintf("block %q requires a single expression", n.Name))
	} else {
		blockExpr = parts[0]
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	itemsVar := g.nextTemp("items")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.Iterate(%s)", itemsVar, valVar)
	g.w.line("if len(%s) > 0 {", itemsVar)
	g.w.indentInc()
	g.w.line("for i, item := range %s {", itemsVar)
	g.w.indentInc()
	dataVar := g.nextTemp("data")
	g.w.line("%s := map[string]any{", dataVar)
	g.w.indentInc()
	g.w.line("%q: item.Index,", "index")
	g.w.line("%q: i == 0,", "first")
	g.w.line("%q: i == len(%s)-1,", "last", itemsVar)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if item.Key != \"\" {")
	g.w.indentInc()
	g.w.line("%s[%q] = item.Key", dataVar, "key")
	g.w.indentDec()
	g.w.line("}")
	localsVar := "nil"
	if len(n.Params) > 0 {
		localsVar = g.nextTemp("locals")
		if len(n.Params) > 1 {
			keyVar := g.nextTemp("key")
			g.w.line("%s := any(item.Index)", keyVar)
			g.w.line("if item.Key != \"\" {")
			g.w.indentInc()
			g.w.line("%s = item.Key", keyVar)
			g.w.indentDec()
			g.w.line("}")
			g.w.line("%s := map[string]any{", localsVar)
			g.w.indentInc()
			g.w.line("%q: item.Value,", n.Params[0])
			g.w.line("%q: %s,", n.Params[1], keyVar)
			g.w.indentDec()
			g.w.line("}")
		} else {
			g.w.line("%s := map[string]any{", localsVar)
			g.w.indentInc()
			g.w.line("%q: item.Value,", n.Params[0])
			g.w.indentDec()
			g.w.line("}")
		}
	}
	g.w.line("ctx := ctx.WithScope(item.Value, %s, %s)", localsVar, dataVar)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitCustomBlockHelper(n *ast.Block) error {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	helperExpr, ok := g.helpers[n.Name]
	if !ok {
		return hexerr.New(fmt.Sprintf("block helper %q is not defined", n.Name))
	}
	if len(parts) == 0 {
		return hexerr.New(fmt.Sprintf("block helper %q requires at least one argument", n.Name))
	}
	if parts[0].kind != exprPath {
		return hexerr.New("block helper name must be a path")
	}

	// Emit block helper call
	// Block helpers receive: context, options with fn/inverse/fnElse
	// We need to create a function that renders the body
	bodyFnVar := g.nextTemp("bodyFn")
	g.w.line("%s := func(ctx *runtime.Context, w io.Writer) error {", bodyFnVar)
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.line("return nil")
	g.w.indentDec()
	g.w.line("}")

	inverseFnVar := "nil"
	if len(n.Else) > 0 {
		inverseFnVar = g.nextTemp("inverseFn")
		g.w.line("%s := func(ctx *runtime.Context, w io.Writer) error {", inverseFnVar)
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.line("return nil")
		g.w.indentDec()
		g.w.line("}")
	}

	// Build options hash
	optionsVar := g.nextTemp("options")
	g.w.line("%s := runtime.BlockOptions{", optionsVar)
	g.w.indentInc()
	g.w.line("Fn: %s,", bodyFnVar)
	if inverseFnVar != "nil" {
		g.w.line("Inverse: %s,", inverseFnVar)
	}
	g.w.indentDec()
	g.w.line("}")

	// Prepare arguments: parts[0] is first arg, options appended later
	argsExpr, err := g.emitArgs(parts, hash)
	if err != nil {
		return err
	}
	// Append options to args
	if argsExpr == "nil" {
		argsExpr = g.nextTemp("args")
		g.w.line("%s := []any{%s}", argsExpr, optionsVar)
	} else {
		argsVar := g.nextTemp("args")
		g.w.line("%s := append(%s, %s)", argsVar, argsExpr, optionsVar)
		argsExpr = argsVar
	}

	// Call block helper; it receives full args (including BlockOptions) and uses GetBlockOptions internally
	hasOptsVar := g.nextTemp("hasOpts")
	g.w.line("_, %s := runtime.GetBlockOptions(%s)", hasOptsVar, argsExpr)
	g.w.line("if !%s {", hasOptsVar)
	g.w.indentInc()
	g.w.line("return fmt.Errorf(\"block helper %%q did not receive BlockOptions\", %q)", n.Name)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if err := %s(ctx, %s); err != nil {", helperExpr, argsExpr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) singleBlockExpr(n *ast.Block) (expr, []hashArg, error) {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return expr{}, nil, err
	}
	if len(parts) != 1 {
		return expr{}, nil, hexerr.New(fmt.Sprintf("block %q requires a single expression", n.Name))
	}
	return parts[0], hash, nil
}

// hashHasIncludeZero reports whether the hash contains includeZero=true.
// Used by {{#if}} / {{#unless}} to enable the includeZero custom extension.
func hashHasIncludeZero(hash []hashArg) bool {
	for _, h := range hash {
		if h.key == "includeZero" && h.value.kind == exprBool && h.value.value == "true" {
			return true
		}
	}
	return false
}

func (g *generator) emitValueExpr(expr string, raw bool) {
	if raw {
		g.writeValue("runtime.WriteRaw", expr)
		return
	}
	g.writeValue("runtime.WriteEscaped", expr)
}

func (g *generator) emitHelperOutput(helperExpr string, args []expr, hash []hashArg, raw bool) error {
	resultVar, err := g.emitHelperValue(helperExpr, args, hash)
	if err != nil {
		return err
	}
	g.emitValueExpr(resultVar, raw)
	return nil
}

func (g *generator) emitHelperValue(helperExpr string, args []expr, hash []hashArg) (string, error) {
	argsExpr, err := g.emitArgs(args, hash)
	if err != nil {
		return "", err
	}
	resultVar := g.nextTemp("result")
	g.w.line("%s, err := %s(ctx, %s)", resultVar, helperExpr, argsExpr)
	g.w.line("if err != nil {")
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return resultVar, nil
}

func (g *generator) emitArgs(args []expr, hash []hashArg) (string, error) {
	argExprs := make([]string, len(args))
	for i, arg := range args {
		var exprValue string
		if arg.kind == exprCall {
			helperExpr, ok := g.helpers[arg.name]
			if !ok {
				return "", hexerr.New(fmt.Sprintf("helper %q is not defined", arg.name))
			}
			var err error
			exprValue, err = g.emitHelperValue(helperExpr, arg.args, arg.hash)
			if err != nil {
				return "", err
			}
		} else {
			a, err := argFromExpr(arg)
			if err != nil {
				return "", err
			}
			exprValue = argExpr(a)
		}
		argExprs[i] = exprValue
	}
	if len(hash) > 0 {
		hashVar, err := g.emitHashMap(hash)
		if err != nil {
			return "", err
		}
		argExprs = append(argExprs, hashVar)
	}
	if len(argExprs) == 0 {
		return "nil", nil
	}
	argsVar := g.nextTemp("args")
	g.w.line("%s := []any{", argsVar)
	g.w.indentInc()
	for _, arg := range argExprs {
		g.w.line("%s,", arg)
	}
	g.w.indentDec()
	g.w.line("}")
	return argsVar, nil
}

type hashEntry struct {
	key   string
	value string
}

func (g *generator) emitHashMap(hash []hashArg) (string, error) {
	if len(hash) == 0 {
		return "nil", nil
	}
	entries := make([]hashEntry, 0, len(hash))
	for _, h := range hash {
		valueExpr, err := g.emitExprValue(h.value)
		if err != nil {
			return "", err
		}
		entries = append(entries, hashEntry{key: h.key, value: valueExpr})
	}
	hashVar := g.nextTemp("hash")
	g.w.line("%s := runtime.Hash{", hashVar)
	g.w.indentInc()
	for _, entry := range entries {
		g.w.line("%s: %s,", strconv.Quote(entry.key), entry.value)
	}
	g.w.indentDec()
	g.w.line("}")
	return hashVar, nil
}

func (g *generator) emitExprValue(value expr) (string, error) {
	if value.kind == exprCall {
		helperExpr, ok := g.helpers[value.name]
		if !ok {
			return "", hexerr.New(fmt.Sprintf("helper %q is not defined", value.name))
		}
		return g.emitHelperValue(helperExpr, value.args, value.hash)
	}
	// Inline literals directly instead of using EvalArg
	valueExpr, err := g.emitLiteralValue(value)
	if err != nil {
		return "", err
	}
	return valueExpr, nil
}

func (g *generator) emitLiteralValue(value expr) (string, error) {
	switch value.kind {
	case exprPath:
		return g.emitPathValue(value.value), nil
	case exprString:
		return strconv.Quote(value.value), nil
	case exprNumber:
		return formatNumberLiteral(value.value)
	case exprBool:
		return value.value, nil
	case exprNull:
		return "nil", nil
	default:
		return "", hexerr.New("invalid expression")
	}
}

func (g *generator) emitPathValue(path string) string {
	return fmt.Sprintf("runtime.ResolvePathValue(ctx, %s)", strconv.Quote(path))
}

func (g *generator) writeValue(fn string, expr string) {
	g.w.line("if err := %s(w, %s); err != nil {", fn, expr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
}

func (g *generator) nextTemp(prefix string) string {
	g.tempID++
	return fmt.Sprintf("%s%d", prefix, g.tempID)
}

func formatNumberLiteral(value string) (string, error) {
	if strings.ContainsAny(value, ".eE") {
		f, err := strconv.ParseFloat(value, 64)
		if err != nil {
			return "", err
		}
		literal := strconv.FormatFloat(f, 'g', -1, 64)
		if !strings.ContainsAny(literal, ".eE") {
			literal += ".0"
		}
		return "float64(" + literal + ")", nil
	}
	if i, err := strconv.ParseInt(value, 10, 64); err == nil {
		return fmt.Sprintf("int64(%d)", i), nil
	}
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return "", err
	}
	literal := strconv.FormatFloat(f, 'g', -1, 64)
	if !strings.ContainsAny(literal, ".eE") {
		literal += ".0"
	}
	return "float64(" + literal + ")", nil
}

type arg struct {
	kind  string
	value string
}

func argFromExpr(value expr) (arg, error) {
	switch value.kind {
	case exprPath:
		return arg{kind: "runtime.ArgPath", value: value.value}, nil
	case exprString:
		return arg{kind: "runtime.ArgString", value: value.value}, nil
	case exprNumber:
		return arg{kind: "runtime.ArgNumber", value: value.value}, nil
	case exprBool:
		return arg{kind: "runtime.ArgBool", value: value.value}, nil
	case exprNull:
		return arg{kind: "runtime.ArgNull", value: ""}, nil
	default:
		return arg{}, hexerr.New("invalid expression")
	}
}

func argExpr(arg arg) string {
	return fmt.Sprintf("runtime.EvalArg(ctx, %s, %s)", arg.kind, strconv.Quote(arg.value))
}

func isNumber(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}

type codeWriter struct {
	buf    bytes.Buffer
	indent int
}

func (w *codeWriter) indentInc() {
	w.indent++
}

func (w *codeWriter) indentDec() {
	if w.indent > 0 {
		w.indent--
	}
}

func (w *codeWriter) line(format string, args ...any) {
	fmt.Fprintf(&w.buf, format, args...)
	w.buf.WriteByte('\n')
}

func (w *codeWriter) String() string {
	return w.buf.String()
}

func goIdent(name string) string {
	if name == "" {
		return "Template"
	}
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	if len(parts) == 0 {
		return "Template"
	}
	var sb strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		sb.WriteString(capitalize(part))
	}
	out := sb.String()
	if out == "" || (out[0] >= '0' && out[0] <= '9') {
		return "Template" + out
	}
	return out
}

func capitalize(part string) string {
	if part == "" {
		return ""
	}
	b := []byte(part)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - 'a' + 'A'
	}
	return string(b)
}

func isIdent(value string) bool {
	if value == "" {
		return false
	}
	for i := 0; i < len(value); i++ {
		ch := value[i]
		if i == 0 {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_') {
				return false
			}
			continue
		}
		if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
			return false
		}
	}
	return true
}

// generateBootstrapCode generates helper functions for quick server/processor setup.
func generateBootstrapCode(w *codeWriter, templateNames []string, funcNames map[string]string) {
	// Generate renderer map
	w.line("")
	w.line("// rendererFuncs maps template names to render functions.")
	w.line("var rendererFuncs = map[string]func(io.Writer, any) error{")
	w.indentInc()
	for _, name := range templateNames {
		goName := funcNames[name]
		w.line("%q: Render%s,", name, goName)
	}
	w.indentDec()
	w.line("}")

	// Generate NewRenderer function
	w.line("")
	w.line("// NewRenderer returns a ready-to-use template renderer.")
	w.line("// This renderer can be used with sitegen.NewProcessor or sitegen.NewServer.")
	w.line("func NewRenderer() processor.TemplateRenderer {")
	w.indentInc()
	w.line("return sitegen.NewRendererFromFunctions(rendererFuncs)")
	w.indentDec()
	w.line("}")

	// Generate quick processor function
	w.line("")
	w.line("// NewQuickProcessor creates a processor with default configuration.")
	w.line("// Use this for quick static site generation.")
	w.line("func NewQuickProcessor() (*sitegen.Processor, error) {")
	w.indentInc()
	w.line("config := sitegen.DefaultConfig()")
	w.line("renderer := NewRenderer()")
	w.line("return sitegen.NewProcessor(config, renderer)")
	w.indentDec()
	w.line("}")

	// Generate quick server function
	w.line("")
	w.line("// NewQuickServer creates a server with default configuration.")
	w.line("// Use this for quick development server setup.")
	w.line("func NewQuickServer() (*sitegen.Server, error) {")
	w.indentInc()
	w.line("config := sitegen.DefaultConfig()")
	w.line("renderer := NewRenderer()")
	w.line("return sitegen.NewServer(config, renderer)")
	w.indentDec()
	w.line("}")
}
