package compiler

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/andriyg76/go-hbars/internal/ast"
	"github.com/andriyg76/go-hbars/internal/parser"
)

// HelperRef points to a helper implementation.
type HelperRef struct {
	ImportPath string
	Ident      string
}

// LayoutContentConfig enables layout-first (Direction B) render: layout runs first
// with lazy slots; content runs when layout invokes it (e.g. {{> content}}).
type LayoutContentConfig struct {
	Layout  string // Template name for the layout (e.g. "layout")
	Content string // Template name for the content partial (e.g. "main")
}

// Options configures code generation.
type Options struct {
	PackageName       string
	RuntimeImport     string
	Helpers           map[string]HelperRef
	GenerateBootstrap bool // Generate bootstrap code for server/processor
	LayoutContent     *LayoutContentConfig
}

// CompileTemplates compiles templates into Go source code.
func CompileTemplates(templates map[string]string, opts Options) ([]byte, error) {
	if opts.PackageName == "" {
		return nil, errors.New("compiler: package name is required")
	}
	runtimeImport := opts.RuntimeImport
	if runtimeImport == "" {
		runtimeImport = "github.com/andriyg76/go-hbars/runtime"
	}
	helperExprs, helperImports, err := prepareHelpers(opts.Helpers, runtimeImport)
	if err != nil {
		return nil, err
	}

	names := make([]string, 0, len(templates))
	parsed := make(map[string][]ast.Node, len(templates))
	for name, tmpl := range templates {
		nodes, err := parser.Parse(tmpl)
		if err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		parsed[name] = nodes
		names = append(names, name)
	}
	sort.Strings(names)

	funcNames := make(map[string]string, len(names))
	seenFunc := make(map[string]string, len(names))
	for _, name := range names {
		ident := goIdent(name)
		if prev, exists := seenFunc[ident]; exists {
			return nil, fmt.Errorf("compiler: templates %q and %q map to %q", prev, name, ident)
		}
		seenFunc[ident] = name
		funcNames[name] = ident
	}

	needFmt := templatesUseBlockHelpers(parsed, helperExprs)
	needBytes := opts.LayoutContent != nil &&
		funcNames[opts.LayoutContent.Layout] != "" &&
		funcNames[opts.LayoutContent.Content] != ""
	header := &codeWriter{}
	header.line("// Code generated by hbc; DO NOT EDIT.")
	header.line("package %s", opts.PackageName)
	header.line("")
	header.line("import (")
	header.indentInc()
	if needFmt {
		header.line("%q", "fmt")
	}
	if needBytes {
		header.line("%q", "bytes")
	}
	header.line("%q", "io")
	header.line("%q", "strings")
	header.line("runtime %q", runtimeImport)
	for _, imp := range helperImports {
		if imp.name == "" {
			header.line("%q", imp.path)
		} else {
			header.line("%s %q", imp.name, imp.path)
		}
	}
	if opts.GenerateBootstrap {
		header.line("%q", "github.com/andriyg76/go-hbars/internal/processor")
		header.line("%q", "github.com/andriyg76/go-hbars/pkg/sitegen")
	}
	header.indentDec()
	header.line(")")
	header.line("")

	partials := &codeWriter{}
	partials.line("var partials map[string]func(*runtime.Context, io.Writer) error")
	partials.line("")
	partials.line("func init() {")
	partials.indentInc()
	partials.line("partials = map[string]func(*runtime.Context, io.Writer) error{")
	partials.indentInc()
	for _, name := range names {
		partials.line("%q: render%s,", name, funcNames[name])
	}
	partials.indentDec()
	partials.line("}")
	partials.indentDec()
	partials.line("}")
	partials.line("")

	statics := &codeWriter{}
	state := &genState{
		statics:     statics,
		staticPaths: make(map[string]string),
	}

	functions := &codeWriter{}
	for _, name := range names {
		goName := funcNames[name]
		nodes := parsed[name]
		gen := &generator{w: functions, helpers: helperExprs, partials: funcNames, state: state}
		functions.line("func render%s(ctx *runtime.Context, w io.Writer) error {", goName)
		functions.indentInc()
		functions.line("ctx.Output = w")
		if err := gen.emitNodes(nodes); err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		functions.line("return nil")
		functions.indentDec()
		functions.line("}")
		functions.line("")
		functions.line("func Render%s(w io.Writer, data any) error {", goName)
		functions.indentInc()
		functions.line("ctx := runtime.NewContext(data)")
		functions.line("return render%s(ctx, w)", goName)
		functions.indentDec()
		functions.line("}")
		functions.line("")
		functions.line("func Render%sString(data any) (string, error) {", goName)
		functions.indentInc()
		functions.line("var b strings.Builder")
		functions.line("if err := Render%s(&b, data); err != nil {", goName)
		functions.indentInc()
		functions.line("return \"\", err")
		functions.indentDec()
		functions.line("}")
		functions.line("return b.String(), nil")
		functions.indentDec()
		functions.line("}")
		functions.line("")
	}

	if opts.LayoutContent != nil {
		layoutName := opts.LayoutContent.Layout
		contentName := opts.LayoutContent.Content
		layoutGo := funcNames[layoutName]
		contentGo := funcNames[contentName]
		if layoutGo != "" && contentGo != "" {
			functions.line("// RenderWithLayout runs layout-first (Direction B) with lazy slots: layout runs first,")
			functions.line("// content runs when layout invokes it (e.g. {{> %s}}).", contentName)
			functions.line("func RenderWithLayout(w io.Writer, data any) error {")
			functions.indentInc()
			functions.line("buf := &bytes.Buffer{}")
			functions.line("recorder := runtime.NewLazySlotsRecorder()")
			functions.line("ctx := runtime.NewContext(data)")
			functions.line("ctx.Output = buf")
			functions.line("ctx.LazySlots = recorder")
			functions.line("ctx.Blocks = make(map[string]string)")
			functions.line("if err := render%s(ctx, buf); err != nil {", layoutGo)
			functions.indentInc()
			functions.line("return err")
			functions.indentDec()
			functions.line("}")
			functions.line("if err := runtime.ResolveLazySlots(buf, recorder.Slots(), ctx.Blocks, ctx); err != nil {")
			functions.indentInc()
			functions.line("return err")
			functions.indentDec()
			functions.line("}")
			functions.line("_, err := buf.WriteTo(w)")
			functions.line("return err")
			functions.indentDec()
			functions.line("}")
			functions.line("")
			functions.line("func RenderWithLayoutString(data any) (string, error) {")
			functions.indentInc()
			functions.line("var b strings.Builder")
			functions.line("if err := RenderWithLayout(&b, data); err != nil {")
			functions.indentInc()
			functions.line("return \"\", err")
			functions.indentDec()
			functions.line("}")
			functions.line("return b.String(), nil")
			functions.indentDec()
			functions.line("}")
			functions.line("")
		}
	}

	// Generate bootstrap code if requested
	bootstrap := &codeWriter{}
	if opts.GenerateBootstrap {
		generateBootstrapCode(bootstrap, names, funcNames)
	}

	var out strings.Builder
	out.WriteString(header.String())
	if statics.String() != "" {
		out.WriteString(statics.String())
		out.WriteString("\n")
	}
	out.WriteString(partials.String())
	out.WriteString(functions.String())
	if bootstrap.String() != "" {
		out.WriteString(bootstrap.String())
	}

	formatted, err := format.Source([]byte(out.String()))
	if err != nil {
		return nil, fmt.Errorf("compiler: format: %w", err)
	}
	return formatted, nil
}

type importSpec struct {
	path string
	name string
}

func prepareHelpers(helpers map[string]HelperRef, runtimeImport string) (map[string]string, []importSpec, error) {
	helperExprs := make(map[string]string)
	if len(helpers) == 0 {
		return helperExprs, nil, nil
	}
	usedNames := map[string]bool{
		"io":      true,
		"strings": true,
		"runtime": true,
	}
	aliases := make(map[string]string)
	names := make([]string, 0, len(helpers))
	for name := range helpers {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		ref := helpers[name]
		if name == "" {
			return nil, nil, fmt.Errorf("compiler: helper name is empty")
		}
		if ref.Ident == "" {
			return nil, nil, fmt.Errorf("compiler: helper %q has empty identifier", name)
		}
		if ref.ImportPath == "" {
			helperExprs[name] = ref.Ident
			continue
		}
		if strings.Contains(ref.Ident, ".") || !isIdent(ref.Ident) {
			return nil, nil, fmt.Errorf("compiler: helper %q identifier %q must be a Go identifier", name, ref.Ident)
		}
		if runtimeImport != "" && ref.ImportPath == runtimeImport {
			helperExprs[name] = "runtime." + ref.Ident
			continue
		}
		alias, ok := aliases[ref.ImportPath]
		if !ok {
			base := sanitizeImportName(path.Base(ref.ImportPath))
			alias = uniqueAlias(base, usedNames)
			aliases[ref.ImportPath] = alias
			usedNames[alias] = true
		}
		helperExprs[name] = alias + "." + ref.Ident
	}
	imports := make([]importSpec, 0, len(aliases))
	for importPath, alias := range aliases {
		imports = append(imports, importSpec{path: importPath, name: alias})
	}
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].path < imports[j].path
	})
	return helperExprs, imports, nil
}

func templatesUseBlockHelpers(parsed map[string][]ast.Node, helperExprs map[string]string) bool {
	builtinBlocks := map[string]bool{"if": true, "unless": true, "with": true, "each": true}
	var walk func(nodes []ast.Node) bool
	walk = func(nodes []ast.Node) bool {
		for _, node := range nodes {
			switch n := node.(type) {
			case *ast.Block:
				if !builtinBlocks[n.Name] && helperExprs[n.Name] != "" {
					return true
				}
				if walk(n.Body) || walk(n.Else) {
					return true
				}
			case *ast.PartialBlock:
				if walk(n.Body) || walk(n.Fallback) {
					return true
				}
			}
		}
		return false
	}
	for _, nodes := range parsed {
		if walk(nodes) {
			return true
		}
	}
	return false
}

func sanitizeImportName(base string) string {
	if base == "" {
		return "pkg"
	}
	b := make([]byte, 0, len(base))
	for i := 0; i < len(base); i++ {
		ch := base[i]
		if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_' {
			b = append(b, ch)
		} else {
			b = append(b, '_')
		}
	}
	if len(b) == 0 {
		return "pkg"
	}
	if b[0] >= '0' && b[0] <= '9' {
		b = append([]byte{'_'}, b...)
	}
	return string(b)
}

func uniqueAlias(base string, used map[string]bool) string {
	if base == "" {
		base = "pkg"
	}
	if !used[base] {
		return base
	}
	for i := 2; ; i++ {
		name := fmt.Sprintf("%s%d", base, i)
		if !used[name] {
			return name
		}
	}
}

type genState struct {
	statics      *codeWriter
	staticHashID int
	staticPathID int
	staticPaths  map[string]string
}

type generator struct {
	w        *codeWriter
	helpers  map[string]string
	partials map[string]string
	tempID   int
	state    *genState
}

func (g *generator) emitNodes(nodes []ast.Node) error {
	for _, node := range nodes {
		switch n := node.(type) {
		case *ast.Text:
			if n.Value != "" {
				g.w.line("if _, err := io.WriteString(w, %s); err != nil {", strconv.Quote(n.Value))
				g.w.indentInc()
				g.w.line("return err")
				g.w.indentDec()
				g.w.line("}")
			}
		case *ast.Mustache:
			if err := g.emitMustache(n); err != nil {
				return err
			}
		case *ast.Partial:
			if err := g.emitPartial(n); err != nil {
				return err
			}
		case *ast.Block:
			if err := g.emitBlock(n); err != nil {
				return err
			}
		case *ast.PartialBlock:
			if err := g.emitPartialBlock(n); err != nil {
				return err
			}
		default:
			return fmt.Errorf("compiler: unsupported node %T", node)
		}
	}
	return nil
}

func (g *generator) emitBlock(n *ast.Block) error {
	switch n.Name {
	case "if":
		return g.emitIfBlock(n, false)
	case "unless":
		return g.emitIfBlock(n, true)
	case "with":
		return g.emitWithBlock(n)
	case "each":
		return g.emitEachBlock(n)
	default:
		// Custom block helper
		return g.emitCustomBlockHelper(n)
	}
}

func (g *generator) emitMustache(n *ast.Mustache) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		if len(hash) > 0 {
			return fmt.Errorf("unexpected hash arguments")
		}
		return nil
	}
	if len(parts) == 1 {
		if parts[0].kind == exprPath {
			if helperExpr, ok := g.helpers[parts[0].value]; ok {
				return g.emitHelperOutput(helperExpr, nil, hash, n.Raw)
			}
		}
		if len(hash) > 0 {
			return fmt.Errorf("hash arguments require a helper")
		}
		valueExpr, err := g.emitExprValue(parts[0])
		if err != nil {
			return err
		}
		g.emitValueExpr(valueExpr, n.Raw)
		return nil
	}
	if parts[0].kind != exprPath {
		return fmt.Errorf("helper name must be a path")
	}
	helperExpr, ok := g.helpers[parts[0].value]
	if !ok {
		return fmt.Errorf("helper %q is not defined", parts[0].value)
	}
	return g.emitHelperOutput(helperExpr, parts[1:], hash, n.Raw)
}

func (g *generator) emitPartial(n *ast.Partial) error {
	parts, hash, err := parseParts(n.Expr)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return fmt.Errorf("partial invocation is empty")
	}
	if len(parts) > 2 {
		return fmt.Errorf("partial: context must be a single expression")
	}
	nameExpr := parts[0]
	var ctxExpr expr
	hasCtx := false
	if len(parts) == 2 {
		ctxExpr = parts[1]
		hasCtx = true
	}
	localsVar := "nil"
	if len(hash) > 0 {
		localsVar, err = g.emitHashMap(hash)
		if err != nil {
			return err
		}
	}
	ctxVar := "ctx"
	if hasCtx {
		valueExpr, err := g.emitExprValue(ctxExpr)
		if err != nil {
			return err
		}
		valVar := g.nextTemp("val")
		g.w.line("%s := %s", valVar, valueExpr)
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(%s, %s, nil)", ctxVar, valVar, localsVar)
	} else if localsVar != "nil" {
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(ctx.Data, %s, nil)", ctxVar, localsVar)
	}

	if nameExpr.kind == exprString {
		name := nameExpr.value
		goName, ok := g.partials[name]
		if !ok {
			return fmt.Errorf("partial %q is not defined", name)
		}
		g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
		g.w.indentInc()
		g.w.line("return err")
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	if nameExpr.kind == exprPath {
		if goName, ok := g.partials[nameExpr.value]; ok {
			g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
			g.w.indentInc()
			g.w.line("return err")
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		return fmt.Errorf("partial %q is not defined", nameExpr.value)
	}

	nameValue, err := g.emitExprValue(nameExpr)
	if err != nil {
		return err
	}
	nameVar := g.nextTemp("partial")
	g.w.line("%s := runtime.Stringify(%s)", nameVar, nameValue)
	g.w.line("partialFn, ok := partials[%s]", nameVar)
	g.w.line("if !ok {")
	g.w.indentInc()
	g.w.line("return runtime.MissingPartial(%s)", nameVar)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if err := partialFn(%s, w); err != nil {", ctxVar)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitIfBlock(n *ast.Block, inverted bool) error {
	if len(n.Params) > 1 {
		return fmt.Errorf("block %q supports a single param", n.Name)
	}
	blockExpr, hash, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	useIncludeZero := hashHasIncludeZero(hash)
	if truthy, ok, err := literalTruthy(blockExpr); ok {
		if err != nil {
			return err
		}
		if useIncludeZero && literalNumericZero(blockExpr) {
			truthy = true
		}
		if inverted {
			truthy = !truthy
		}
		if truthy {
			if len(n.Params) > 0 {
				valueExpr, err := g.emitLiteralValue(blockExpr)
				if err != nil {
					return err
				}
				localsVar := g.nextTemp("locals")
				g.w.line("{")
				g.w.indentInc()
				g.w.line("%s := map[string]any{", localsVar)
				g.w.indentInc()
				g.w.line("%q: %s,", n.Params[0], valueExpr)
				g.w.indentDec()
				g.w.line("}")
				g.w.line("ctx := ctx.WithScope(ctx.Data, %s, nil)", localsVar)
				if err := g.emitNodes(n.Body); err != nil {
					return err
				}
				g.w.indentDec()
				g.w.line("}")
				return nil
			}
			return g.emitNodes(n.Body)
		}
		if len(n.Else) > 0 {
			return g.emitNodes(n.Else)
		}
		return nil
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, valueExpr)
	if useIncludeZero {
		g.w.line("%s := runtime.IncludeZeroTruthy(%s)", condVar, valVar)
	} else {
		g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	}
	condExpr := condVar
	if inverted {
		condExpr = "!" + condVar
	}
	
	// Support block params for if/unless
	localsVar := "nil"
	if len(n.Params) > 0 {
		if len(n.Params) > 1 {
			return fmt.Errorf("block %q supports a single param", n.Name)
		}
		localsVar = g.nextTemp("locals")
		g.w.line("%s := map[string]any{", localsVar)
		g.w.indentInc()
		g.w.line("%q: %s,", n.Params[0], valVar)
		g.w.indentDec()
		g.w.line("}")
	}
	
	g.w.line("if %s {", condExpr)
	g.w.indentInc()
	if len(n.Params) > 0 {
		g.w.line("ctx := ctx.WithScope(ctx.Data, %s, nil)", localsVar)
	}
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitWithBlock(n *ast.Block) error {
	if len(n.Params) > 1 {
		return fmt.Errorf("block %q supports a single param", n.Name)
	}
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	if truthy, ok, err := literalTruthy(blockExpr); ok {
		if err != nil {
			return err
		}
		if truthy {
			valueExpr, err := g.emitLiteralValue(blockExpr)
			if err != nil {
				return err
			}
			localsVar := "nil"
			g.w.line("{")
			g.w.indentInc()
			if len(n.Params) == 1 {
				localsVar = g.nextTemp("locals")
				g.w.line("%s := map[string]any{", localsVar)
				g.w.indentInc()
				g.w.line("%q: %s,", n.Params[0], valueExpr)
				g.w.indentDec()
				g.w.line("}")
			}
			g.w.line("ctx := ctx.WithScope(%s, %s, nil)", valueExpr, localsVar)
			if err := g.emitNodes(n.Body); err != nil {
				return err
			}
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		if len(n.Else) > 0 {
			return g.emitNodes(n.Else)
		}
		return nil
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	condVar := g.nextTemp("cond")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.IsTruthy(%s)", condVar, valVar)
	g.w.line("if %s {", condVar)
	g.w.indentInc()
	localsVar := "nil"
	if len(n.Params) == 1 {
		localsVar = g.nextTemp("locals")
		g.w.line("%s := map[string]any{", localsVar)
		g.w.indentInc()
		g.w.line("%q: %s,", n.Params[0], valVar)
		g.w.indentDec()
		g.w.line("}")
	}
	g.w.line("ctx := ctx.WithScope(%s, %s, nil)", valVar, localsVar)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitEachBlock(n *ast.Block) error {
	if len(n.Params) > 2 {
		return fmt.Errorf("block %q supports up to 2 params", n.Name)
	}
	blockExpr, _, err := g.singleBlockExpr(n)
	if err != nil {
		return err
	}
	valueExpr, err := g.emitExprValue(blockExpr)
	if err != nil {
		return err
	}
	valVar := g.nextTemp("val")
	itemsVar := g.nextTemp("items")
	g.w.line("%s := %s", valVar, valueExpr)
	g.w.line("%s := runtime.Iterate(%s)", itemsVar, valVar)
	g.w.line("if len(%s) > 0 {", itemsVar)
	g.w.indentInc()
	g.w.line("for i, item := range %s {", itemsVar)
	g.w.indentInc()
	dataVar := g.nextTemp("data")
	g.w.line("%s := map[string]any{", dataVar)
	g.w.indentInc()
	g.w.line("%q: item.Index,", "index")
	g.w.line("%q: i == 0,", "first")
	g.w.line("%q: i == len(%s)-1,", "last", itemsVar)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if item.Key != \"\" {")
	g.w.indentInc()
	g.w.line("%s[%q] = item.Key", dataVar, "key")
	g.w.indentDec()
	g.w.line("}")
	localsVar := "nil"
	if len(n.Params) > 0 {
		localsVar = g.nextTemp("locals")
		if len(n.Params) > 1 {
			keyVar := g.nextTemp("key")
			g.w.line("%s := any(item.Index)", keyVar)
			g.w.line("if item.Key != \"\" {")
			g.w.indentInc()
			g.w.line("%s = item.Key", keyVar)
			g.w.indentDec()
			g.w.line("}")
			g.w.line("%s := map[string]any{", localsVar)
			g.w.indentInc()
			g.w.line("%q: item.Value,", n.Params[0])
			g.w.line("%q: %s,", n.Params[1], keyVar)
			g.w.indentDec()
			g.w.line("}")
		} else {
			g.w.line("%s := map[string]any{", localsVar)
			g.w.indentInc()
			g.w.line("%q: item.Value,", n.Params[0])
			g.w.indentDec()
			g.w.line("}")
		}
	}
	g.w.line("ctx := ctx.WithScope(item.Value, %s, %s)", localsVar, dataVar)
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	if len(n.Else) > 0 {
		g.w.line("} else {")
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.indentDec()
	}
	g.w.line("}")
	return nil
}

func (g *generator) emitCustomBlockHelper(n *ast.Block) error {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	helperExpr, ok := g.helpers[n.Name]
	if !ok {
		return fmt.Errorf("block helper %q is not defined", n.Name)
	}
	if len(parts) == 0 {
		return fmt.Errorf("block helper %q requires at least one argument", n.Name)
	}
	// block/partial accept a slot name (string or path) as first arg; others require path
	if n.Name != "block" && n.Name != "partial" && parts[0].kind != exprPath {
		return fmt.Errorf("block helper name must be a path")
	}
	
	// Emit block helper call
	// Block helpers receive: context, options with fn/inverse/fnElse
	// We need to create a function that renders the body
	bodyFnVar := g.nextTemp("bodyFn")
	g.w.line("%s := func(ctx *runtime.Context, w io.Writer) error {", bodyFnVar)
	g.w.indentInc()
	if err := g.emitNodes(n.Body); err != nil {
		return err
	}
	g.w.line("return nil")
	g.w.indentDec()
	g.w.line("}")
	
	inverseFnVar := "nil"
	if len(n.Else) > 0 {
		inverseFnVar = g.nextTemp("inverseFn")
		g.w.line("%s := func(ctx *runtime.Context, w io.Writer) error {", inverseFnVar)
		g.w.indentInc()
		if err := g.emitNodes(n.Else); err != nil {
			return err
		}
		g.w.line("return nil")
		g.w.indentDec()
		g.w.line("}")
	}
	
	// Build options hash
	optionsVar := g.nextTemp("options")
	g.w.line("%s := runtime.BlockOptions{", optionsVar)
	g.w.indentInc()
	g.w.line("Fn: %s,", bodyFnVar)
	if inverseFnVar != "nil" {
		g.w.line("Inverse: %s,", inverseFnVar)
	}
	g.w.indentDec()
	g.w.line("}")
	
	// Prepare arguments: parts[0] is first arg (e.g. slot name for block/partial), options appended later
	argsExpr, err := g.emitArgs(parts, hash)
	if err != nil {
		return err
	}
	// Append options to args
	if argsExpr == "nil" {
		argsExpr = g.nextTemp("args")
		g.w.line("%s := []any{%s}", argsExpr, optionsVar)
	} else {
		argsVar := g.nextTemp("args")
		g.w.line("%s := append(%s, %s)", argsVar, argsExpr, optionsVar)
		argsExpr = argsVar
	}
	
	// Call block helper; it receives full args (including BlockOptions) and uses GetBlockOptions internally
	hasOptsVar := g.nextTemp("hasOpts")
	g.w.line("_, %s := runtime.GetBlockOptions(%s)", hasOptsVar, argsExpr)
	g.w.line("if !%s {", hasOptsVar)
	g.w.indentInc()
	g.w.line("return fmt.Errorf(\"block helper %%q did not receive BlockOptions\", %q)", n.Name)
	g.w.indentDec()
	g.w.line("}")
	g.w.line("if err := %s(ctx, %s); err != nil {", helperExpr, argsExpr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitPartialBlock(n *ast.PartialBlock) error {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return err
	}
	if len(parts) == 0 {
		return fmt.Errorf("partial block invocation is empty")
	}
	if len(parts) > 2 {
		return fmt.Errorf("partial block: context must be a single expression")
	}
	nameExpr := parts[0]
	var ctxExpr expr
	hasCtx := false
	if len(parts) == 2 {
		ctxExpr = parts[1]
		hasCtx = true
	}
	localsVar := "nil"
	if len(hash) > 0 {
		localsVar, err = g.emitHashMap(hash)
		if err != nil {
			return err
		}
	}
	ctxVar := "ctx"
	if hasCtx {
		valueExpr, err := g.emitExprValue(ctxExpr)
		if err != nil {
			return err
		}
		valVar := g.nextTemp("val")
		g.w.line("%s := %s", valVar, valueExpr)
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(%s, %s, nil)", ctxVar, valVar, localsVar)
	} else if localsVar != "nil" {
		ctxVar = g.nextTemp("ctx")
		g.w.line("%s := ctx.WithScope(ctx.Data, %s, nil)", ctxVar, localsVar)
	}
	
	// Try to render partial, fallback to block content if not found
	if nameExpr.kind == exprString {
		name := nameExpr.value
		goName, ok := g.partials[name]
		if ok {
			// Partial exists, render it
			g.w.line("if err := render%s(%s, w); err != nil {", goName, ctxVar)
			g.w.indentInc()
			g.w.line("return err")
			g.w.indentDec()
			g.w.line("}")
			return nil
		}
		// Partial doesn't exist, render fallback
		if err := g.emitNodes(n.Fallback); err != nil {
			return err
		}
		return nil
	}
	
	// Dynamic partial name
	nameValue, err := g.emitExprValue(nameExpr)
	if err != nil {
		return err
	}
	nameVar := g.nextTemp("partial")
	g.w.line("%s := runtime.Stringify(%s)", nameVar, nameValue)
	g.w.line("partialFn, ok := partials[%s]", nameVar)
	g.w.line("if ok {")
	g.w.indentInc()
	g.w.line("if err := partialFn(%s, w); err != nil {", ctxVar)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	g.w.indentDec()
	g.w.line("} else {")
	g.w.indentInc()
	// Render fallback
	if err := g.emitNodes(n.Fallback); err != nil {
		return err
	}
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) singleBlockExpr(n *ast.Block) (expr, []hashArg, error) {
	parts, hash, err := parseParts(n.Args)
	if err != nil {
		return expr{}, nil, err
	}
	if len(parts) != 1 {
		return expr{}, nil, fmt.Errorf("block %q requires a single expression", n.Name)
	}
	return parts[0], hash, nil
}

// hashHasIncludeZero reports whether the hash contains includeZero=true.
// Used by {{#if}} / {{#unless}} to enable the includeZero custom extension.
func hashHasIncludeZero(hash []hashArg) bool {
	for _, h := range hash {
		if h.key == "includeZero" && h.value.kind == exprBool && h.value.value == "true" {
			return true
		}
	}
	return false
}

func (g *generator) emitValueExpr(expr string, raw bool) {
	if raw {
		g.writeValue("runtime.WriteRaw", expr)
		return
	}
	g.writeValue("runtime.WriteEscaped", expr)
}

func (g *generator) emitHelperOutput(helperExpr string, args []expr, hash []hashArg, raw bool) error {
	resultVar, err := g.emitHelperValue(helperExpr, args, hash)
	if err != nil {
		return err
	}
	g.emitValueExpr(resultVar, raw)
	return nil
}

func (g *generator) emitHelperValue(helperExpr string, args []expr, hash []hashArg) (string, error) {
	argsExpr, err := g.emitArgs(args, hash)
	if err != nil {
		return "", err
	}
	resultVar := g.nextTemp("result")
	g.w.line("%s, err := %s(ctx, %s)", resultVar, helperExpr, argsExpr)
	g.w.line("if err != nil {")
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return resultVar, nil
}

func (g *generator) emitArgs(args []expr, hash []hashArg) (string, error) {
	argExprs := make([]string, len(args))
	for i, arg := range args {
		exprValue, err := g.emitExprValue(arg)
		if err != nil {
			return "", err
		}
		argExprs[i] = exprValue
	}
	if len(hash) > 0 {
		hashVar, err := g.emitHashMap(hash)
		if err != nil {
			return "", err
		}
		argExprs = append(argExprs, hashVar)
	}
	if len(argExprs) == 0 {
		return "nil", nil
	}
	argsVar := g.nextTemp("args")
	g.w.line("%s := []any{", argsVar)
	g.w.indentInc()
	for _, arg := range argExprs {
		g.w.line("%s,", arg)
	}
	g.w.indentDec()
	g.w.line("}")
	return argsVar, nil
}

type hashEntry struct {
	key   string
	value string
}

func (g *generator) emitHashMap(hash []hashArg) (string, error) {
	if len(hash) == 0 {
		return "nil", nil
	}
	entries := make([]hashEntry, 0, len(hash))
	allLiteral := true
	for _, h := range hash {
		if !isLiteralExpr(h.value) {
			allLiteral = false
		}
		valueExpr, err := g.emitExprValue(h.value)
		if err != nil {
			return "", err
		}
		entries = append(entries, hashEntry{key: h.key, value: valueExpr})
	}
	if allLiteral {
		return g.emitStaticHash(entries), nil
	}
	hashVar := g.nextTemp("hash")
	g.w.line("%s := runtime.Hash{", hashVar)
	g.w.indentInc()
	for _, entry := range entries {
		g.w.line("%s: %s,", strconv.Quote(entry.key), entry.value)
	}
	g.w.indentDec()
	g.w.line("}")
	return hashVar, nil
}

func (g *generator) emitStaticHash(entries []hashEntry) string {
	if g.state == nil || g.state.statics == nil {
		hashVar := g.nextTemp("hash")
		g.w.line("%s := runtime.Hash{", hashVar)
		g.w.indentInc()
		for _, entry := range entries {
			g.w.line("%s: %s,", strconv.Quote(entry.key), entry.value)
		}
		g.w.indentDec()
		g.w.line("}")
		return hashVar
	}
	g.state.staticHashID++
	name := fmt.Sprintf("staticHash%d", g.state.staticHashID)
	g.state.statics.line("var %s = runtime.Hash{", name)
	g.state.statics.indentInc()
	for _, entry := range entries {
		g.state.statics.line("%s: %s,", strconv.Quote(entry.key), entry.value)
	}
	g.state.statics.indentDec()
	g.state.statics.line("}")
	g.state.statics.line("")
	return name
}

func (g *generator) emitExprValue(value expr) (string, error) {
	if value.kind == exprCall {
		helperExpr, ok := g.helpers[value.name]
		if !ok {
			return "", fmt.Errorf("helper %q is not defined", value.name)
		}
		return g.emitHelperValue(helperExpr, value.args, value.hash)
	}
	// Inline literals directly instead of using EvalArg
	valueExpr, err := g.emitLiteralValue(value)
	if err != nil {
		return "", err
	}
	return valueExpr, nil
}

func (g *generator) emitLiteralValue(value expr) (string, error) {
	switch value.kind {
	case exprPath:
		return g.emitPathValue(value.value), nil
	case exprString:
		return strconv.Quote(value.value), nil
	case exprNumber:
		return formatNumberLiteral(value.value)
	case exprBool:
		return value.value, nil
	case exprNull:
		return "nil", nil
	default:
		return "", fmt.Errorf("invalid expression")
	}
}

func (g *generator) emitPathValue(path string) string {
	parsed := parsePathLiteral(path)
	if g.state == nil || g.state.statics == nil {
		return fmt.Sprintf("runtime.ResolvePathValueParsed(ctx, %s)", formatParsedPath(parsed))
	}
	name := g.state.pathVar(parsed)
	return fmt.Sprintf("runtime.ResolvePathValueParsed(ctx, %s)", name)
}

func (s *genState) pathVar(path parsedPath) string {
	if s.staticPaths == nil {
		s.staticPaths = make(map[string]string)
	}
	key := parsedPathKey(path)
	if name, ok := s.staticPaths[key]; ok {
		return name
	}
	s.staticPathID++
	name := fmt.Sprintf("staticPath%d", s.staticPathID)
	s.staticPaths[key] = name
	s.statics.line("var %s = %s", name, formatParsedPath(path))
	s.statics.line("")
	return name
}

func (g *generator) writeValue(fn string, expr string) {
	g.w.line("if err := %s(w, %s); err != nil {", fn, expr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
}

func (g *generator) nextTemp(prefix string) string {
	g.tempID++
	return fmt.Sprintf("%s%d", prefix, g.tempID)
}

func isLiteralExpr(value expr) bool {
	switch value.kind {
	case exprString, exprNumber, exprBool, exprNull:
		return true
	default:
		return false
	}
}

func literalTruthy(value expr) (bool, bool, error) {
	switch value.kind {
	case exprString:
		return value.value != "", true, nil
	case exprBool:
		return value.value == "true", true, nil
	case exprNull:
		return false, true, nil
	case exprNumber:
		num, err := strconv.ParseFloat(value.value, 64)
		if err != nil {
			return false, false, err
		}
		return num != 0, true, nil
	default:
		return false, false, nil
	}
}

// literalNumericZero reports whether the expression is a literal numeric zero.
func literalNumericZero(value expr) bool {
	if value.kind != exprNumber {
		return false
	}
	num, err := strconv.ParseFloat(value.value, 64)
	return err == nil && num == 0
}

func formatNumberLiteral(value string) (string, error) {
	if strings.ContainsAny(value, ".eE") {
		f, err := strconv.ParseFloat(value, 64)
		if err != nil {
			return "", err
		}
		literal := strconv.FormatFloat(f, 'g', -1, 64)
		if !strings.ContainsAny(literal, ".eE") {
			literal += ".0"
		}
		return "float64(" + literal + ")", nil
	}
	if i, err := strconv.ParseInt(value, 10, 64); err == nil {
		return fmt.Sprintf("int64(%d)", i), nil
	}
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return "", err
	}
	literal := strconv.FormatFloat(f, 'g', -1, 64)
	if !strings.ContainsAny(literal, ".eE") {
		literal += ".0"
	}
	return "float64(" + literal + ")", nil
}

type parsedPath struct {
	parts   []string
	up      int
	data    bool
	current bool
}

func parsePathLiteral(value string) parsedPath {
	path := strings.TrimSpace(value)
	if path == "" || path == "." || path == "this" {
		return parsedPath{current: true}
	}
	up := 0
	for path == ".." || strings.HasPrefix(path, "../") {
		up++
		if path == ".." {
			path = ""
			break
		}
		path = strings.TrimPrefix(path, "../")
	}
	for strings.HasPrefix(path, "./") {
		path = strings.TrimPrefix(path, "./")
	}
	if path == "" || path == "." || path == "this" {
		return parsedPath{up: up, current: true}
	}
	data := false
	if strings.HasPrefix(path, "@") {
		data = true
		path = strings.TrimPrefix(path, "@")
	}
	var parts []string
	if path != "" {
		for _, part := range strings.Split(path, ".") {
			if part == "" {
				continue
			}
			parts = append(parts, part)
		}
	}
	return parsedPath{
		parts:   parts,
		up:      up,
		data:    data,
		current: false,
	}
}

func parsedPathKey(path parsedPath) string {
	var sb strings.Builder
	sb.WriteString(strconv.Itoa(path.up))
	if path.data {
		sb.WriteString("|data")
	}
	if path.current {
		sb.WriteString("|current")
	}
	for _, part := range path.parts {
		sb.WriteString("|")
		sb.WriteString(part)
	}
	return sb.String()
}

func formatParsedPath(path parsedPath) string {
	var fields []string
	if len(path.parts) > 0 {
		parts := make([]string, len(path.parts))
		for i, part := range path.parts {
			parts[i] = strconv.Quote(part)
		}
		fields = append(fields, fmt.Sprintf("Parts: []string{%s}", strings.Join(parts, ", ")))
	}
	if path.up > 0 {
		fields = append(fields, fmt.Sprintf("Up: %d", path.up))
	}
	if path.data {
		fields = append(fields, "Data: true")
	}
	if path.current {
		fields = append(fields, "Current: true")
	}
	if len(fields) == 0 {
		return "runtime.ParsedPath{}"
	}
	return fmt.Sprintf("runtime.ParsedPath{%s}", strings.Join(fields, ", "))
}

type arg struct {
	kind  string
	value string
}

func argFromExpr(value expr) (arg, error) {
	switch value.kind {
	case exprPath:
		return arg{kind: "runtime.ArgPath", value: value.value}, nil
	case exprString:
		return arg{kind: "runtime.ArgString", value: value.value}, nil
	case exprNumber:
		return arg{kind: "runtime.ArgNumber", value: value.value}, nil
	case exprBool:
		return arg{kind: "runtime.ArgBool", value: value.value}, nil
	case exprNull:
		return arg{kind: "runtime.ArgNull", value: ""}, nil
	default:
		return arg{}, fmt.Errorf("invalid expression")
	}
}

func argExpr(arg arg) string {
	return fmt.Sprintf("runtime.EvalArg(ctx, %s, %s)", arg.kind, strconv.Quote(arg.value))
}

func isNumber(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}

type codeWriter struct {
	buf    bytes.Buffer
	indent int
}

func (w *codeWriter) indentInc() {
	w.indent++
}

func (w *codeWriter) indentDec() {
	if w.indent > 0 {
		w.indent--
	}
}

func (w *codeWriter) line(format string, args ...any) {
	fmt.Fprintf(&w.buf, format, args...)
	w.buf.WriteByte('\n')
}

func (w *codeWriter) String() string {
	return w.buf.String()
}

func goIdent(name string) string {
	if name == "" {
		return "Template"
	}
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	if len(parts) == 0 {
		return "Template"
	}
	var sb strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		sb.WriteString(capitalize(part))
	}
	out := sb.String()
	if out == "" || (out[0] >= '0' && out[0] <= '9') {
		return "Template" + out
	}
	return out
}

func capitalize(part string) string {
	if part == "" {
		return ""
	}
	b := []byte(part)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - 'a' + 'A'
	}
	return string(b)
}

func isIdent(value string) bool {
	if value == "" {
		return false
	}
	for i := 0; i < len(value); i++ {
		ch := value[i]
		if i == 0 {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_') {
				return false
			}
			continue
		}
		if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
			return false
		}
	}
	return true
}

// generateBootstrapCode generates helper functions for quick server/processor setup.
func generateBootstrapCode(w *codeWriter, templateNames []string, funcNames map[string]string) {
	// Generate renderer map
	w.line("")
	w.line("// rendererFuncs maps template names to render functions.")
	w.line("var rendererFuncs = map[string]func(io.Writer, any) error{")
	w.indentInc()
	for _, name := range templateNames {
		goName := funcNames[name]
		w.line("%q: Render%s,", name, goName)
	}
	w.indentDec()
	w.line("}")

	// Generate NewRenderer function
	w.line("")
	w.line("// NewRenderer returns a ready-to-use template renderer.")
	w.line("// This renderer can be used with sitegen.NewProcessor or sitegen.NewServer.")
	w.line("func NewRenderer() processor.TemplateRenderer {")
	w.indentInc()
	w.line("return sitegen.NewRendererFromFunctions(rendererFuncs)")
	w.indentDec()
	w.line("}")

	// Generate quick processor function
	w.line("")
	w.line("// NewQuickProcessor creates a processor with default configuration.")
	w.line("// Use this for quick static site generation.")
	w.line("func NewQuickProcessor() (*sitegen.Processor, error) {")
	w.indentInc()
	w.line("config := sitegen.DefaultConfig()")
	w.line("renderer := NewRenderer()")
	w.line("return sitegen.NewProcessor(config, renderer)")
	w.indentDec()
	w.line("}")

	// Generate quick server function
	w.line("")
	w.line("// NewQuickServer creates a server with default configuration.")
	w.line("// Use this for quick development server setup.")
	w.line("func NewQuickServer() (*sitegen.Server, error) {")
	w.indentInc()
	w.line("config := sitegen.DefaultConfig()")
	w.line("renderer := NewRenderer()")
	w.line("return sitegen.NewServer(config, renderer)")
	w.indentDec()
	w.line("}")
}
