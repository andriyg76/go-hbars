package compiler

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"sort"
	"strconv"
	"strings"

	"github.com/andriyg76/go-hbars/internal/ast"
	"github.com/andriyg76/go-hbars/internal/parser"
)

// Options configures code generation.
type Options struct {
	PackageName   string
	RuntimeImport string
}

// CompileTemplates compiles templates into Go source code.
func CompileTemplates(templates map[string]string, opts Options) ([]byte, error) {
	if opts.PackageName == "" {
		return nil, errors.New("compiler: package name is required")
	}
	runtimeImport := opts.RuntimeImport
	if runtimeImport == "" {
		runtimeImport = "github.com/andriyg76/go-hbars/runtime"
	}
	names := make([]string, 0, len(templates))
	parsed := make(map[string][]ast.Node, len(templates))
	for name, tmpl := range templates {
		nodes, err := parser.Parse(tmpl)
		if err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		parsed[name] = nodes
		names = append(names, name)
	}
	sort.Strings(names)

	w := &codeWriter{}
	w.line("// Code generated by hbc; DO NOT EDIT.")
	w.line("package %s", opts.PackageName)
	w.line("")
	w.line("import (")
	w.indentInc()
	w.line("%q", "strings")
	w.line("%q", runtimeImport)
	w.indentDec()
	w.line(")")
	w.line("")
	w.line("var engine = runtime.NewEngine()")
	w.line("")
	w.line("func Engine() *runtime.Engine {")
	w.indentInc()
	w.line("return engine")
	w.indentDec()
	w.line("}")
	w.line("")
	w.line("func RegisterHelper(name string, h runtime.Helper) {")
	w.indentInc()
	w.line("engine.RegisterHelper(name, h)")
	w.indentDec()
	w.line("}")
	w.line("")
	w.line("func RegisterPartial(name string, t runtime.Template) {")
	w.indentInc()
	w.line("engine.RegisterPartial(name, t)")
	w.indentDec()
	w.line("}")
	w.line("")
	w.line("var Templates = map[string]runtime.Template{")
	w.indentInc()
	for _, name := range names {
		w.line("%q: render%s,", name, goIdent(name))
	}
	w.indentDec()
	w.line("}")
	w.line("")
	w.line("func init() {")
	w.indentInc()
	w.line("for name, tmpl := range Templates {")
	w.indentInc()
	w.line("engine.RegisterPartial(name, tmpl)")
	w.indentDec()
	w.line("}")
	w.indentDec()
	w.line("}")
	w.line("")

	for _, name := range names {
		goName := goIdent(name)
		nodes := parsed[name]
		gen := &generator{w: w, engineVar: "engine"}
		w.line("func render%s(ctx *runtime.Context, b *strings.Builder) error {", goName)
		w.indentInc()
		if err := gen.emitNodes(nodes); err != nil {
			return nil, fmt.Errorf("compiler: template %q: %w", name, err)
		}
		w.line("return nil")
		w.indentDec()
		w.line("}")
		w.line("")
		w.line("func Render%s(data any) (string, error) {", goName)
		w.indentInc()
		w.line("ctx := runtime.NewContext(data, engine)")
		w.line("var b strings.Builder")
		w.line("if err := render%s(ctx, &b); err != nil {", goName)
		w.indentInc()
		w.line("return \"\", err")
		w.indentDec()
		w.line("}")
		w.line("return b.String(), nil")
		w.indentDec()
		w.line("}")
		w.line("")
	}

	formatted, err := format.Source([]byte(w.String()))
	if err != nil {
		return nil, fmt.Errorf("compiler: format: %w", err)
	}
	return formatted, nil
}

type generator struct {
	w         *codeWriter
	engineVar string
	tempID    int
}

func (g *generator) emitNodes(nodes []ast.Node) error {
	for _, node := range nodes {
		switch n := node.(type) {
		case *ast.Text:
			if n.Value != "" {
				g.w.line("b.WriteString(%s)", strconv.Quote(n.Value))
			}
		case *ast.Mustache:
			if err := g.emitMustache(n); err != nil {
				return err
			}
		case *ast.Partial:
			if err := g.emitPartial(n); err != nil {
				return err
			}
		default:
			return fmt.Errorf("compiler: unsupported node %T", node)
		}
	}
	return nil
}

func (g *generator) emitMustache(n *ast.Mustache) error {
	tokens, err := splitArgs(n.Expr)
	if err != nil {
		return err
	}
	if len(tokens) == 0 {
		return nil
	}
	if len(tokens) == 1 {
		arg, err := classifyToken(tokens[0])
		if err != nil {
			return err
		}
		if arg.kind != "runtime.ArgPath" {
			g.emitValue(arg, n.Raw)
			return nil
		}
		name := tokens[0].value
		g.w.line("if %s.HasHelper(%q) {", g.engineVar, name)
		g.w.indentInc()
		g.emitHelperCall(name, nil, n.Raw)
		g.w.indentDec()
		g.w.line("} else {")
		g.w.indentInc()
		g.emitValue(arg, n.Raw)
		g.w.indentDec()
		g.w.line("}")
		return nil
	}
	name := tokens[0].value
	args := make([]arg, 0, len(tokens)-1)
	for _, tok := range tokens[1:] {
		arg, err := classifyToken(tok)
		if err != nil {
			return err
		}
		args = append(args, arg)
	}
	g.emitHelperCall(name, args, n.Raw)
	return nil
}

func (g *generator) emitPartial(n *ast.Partial) error {
	ctxExpr := "nil"
	if n.ContextExpr != "" {
		tokens, err := splitArgs(n.ContextExpr)
		if err != nil {
			return err
		}
		if len(tokens) != 1 {
			return fmt.Errorf("partial %q: context must be a single expression", n.Name)
		}
		arg, err := classifyToken(tokens[0])
		if err != nil {
			return err
		}
		ctxExpr = argExpr(arg)
	}
	g.w.line("if err := %s.RenderPartial(%q, ctx, %s, b); err != nil {", g.engineVar, n.Name, ctxExpr)
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	return nil
}

func (g *generator) emitValue(arg arg, raw bool) {
	if raw {
		g.w.line("runtime.WriteRaw(b, %s)", argExpr(arg))
		return
	}
	g.w.line("runtime.WriteEscaped(b, %s)", argExpr(arg))
}

func (g *generator) emitHelperCall(name string, args []arg, raw bool) {
	argsExpr := "nil"
	if len(args) > 0 {
		argsVar := g.nextTemp("args")
		g.w.line("%s := []any{", argsVar)
		g.w.indentInc()
		for _, arg := range args {
			g.w.line("%s,", argExpr(arg))
		}
		g.w.indentDec()
		g.w.line("}")
		argsExpr = argsVar
	}
	resultVar := g.nextTemp("result")
	g.w.line("%s, err := %s.CallHelper(%q, ctx, %s)", resultVar, g.engineVar, name, argsExpr)
	g.w.line("if err != nil {")
	g.w.indentInc()
	g.w.line("return err")
	g.w.indentDec()
	g.w.line("}")
	if raw {
		g.w.line("runtime.WriteRaw(b, %s)", resultVar)
		return
	}
	g.w.line("runtime.WriteEscaped(b, %s)", resultVar)
}

func (g *generator) nextTemp(prefix string) string {
	g.tempID++
	return fmt.Sprintf("%s%d", prefix, g.tempID)
}

type arg struct {
	kind  string
	value string
}

func classifyToken(tok token) (arg, error) {
	if tok.quoted {
		return arg{kind: "runtime.ArgString", value: tok.value}, nil
	}
	lower := strings.ToLower(tok.value)
	switch lower {
	case "true", "false":
		return arg{kind: "runtime.ArgBool", value: lower}, nil
	case "null", "nil":
		return arg{kind: "runtime.ArgNull", value: ""}, nil
	default:
		if isNumber(tok.value) {
			return arg{kind: "runtime.ArgNumber", value: tok.value}, nil
		}
		return arg{kind: "runtime.ArgPath", value: tok.value}, nil
	}
}

func argExpr(arg arg) string {
	return fmt.Sprintf("runtime.EvalArg(ctx, %s, %s)", arg.kind, strconv.Quote(arg.value))
}

func isNumber(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

type token struct {
	value  string
	quoted bool
}

func splitArgs(input string) ([]token, error) {
	var tokens []token
	for i := 0; i < len(input); {
		for i < len(input) && isSpace(input[i]) {
			i++
		}
		if i >= len(input) {
			break
		}
		switch input[i] {
		case '"', '\'':
			quote := input[i]
			i++
			var sb strings.Builder
			closed := false
			for i < len(input) {
				ch := input[i]
				if ch == '\\' && i+1 < len(input) {
					next := input[i+1]
					if next == quote || next == '\\' {
						sb.WriteByte(next)
						i += 2
						continue
					}
				}
				if ch == quote {
					i++
					closed = true
					break
				}
				sb.WriteByte(ch)
				i++
			}
			if !closed {
				return nil, fmt.Errorf("unclosed string literal")
			}
			tokens = append(tokens, token{value: sb.String(), quoted: true})
		default:
			start := i
			for i < len(input) && !isSpace(input[i]) {
				i++
			}
			tokens = append(tokens, token{value: input[start:i]})
		}
	}
	return tokens, nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}

type codeWriter struct {
	buf    bytes.Buffer
	indent int
}

func (w *codeWriter) indentInc() {
	w.indent++
}

func (w *codeWriter) indentDec() {
	if w.indent > 0 {
		w.indent--
	}
}

func (w *codeWriter) line(format string, args ...any) {
	for i := 0; i < w.indent; i++ {
		w.buf.WriteByte('\t')
	}
	fmt.Fprintf(&w.buf, format, args...)
	w.buf.WriteByte('\n')
}

func (w *codeWriter) String() string {
	return w.buf.String()
}

func goIdent(name string) string {
	if name == "" {
		return "Template"
	}
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	if len(parts) == 0 {
		return "Template"
	}
	var sb strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		sb.WriteString(capitalize(part))
	}
	out := sb.String()
	if out == "" || (out[0] >= '0' && out[0] <= '9') {
		return "Template" + out
	}
	return out
}

func capitalize(part string) string {
	if part == "" {
		return ""
	}
	b := []byte(part)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - 'a' + 'A'
	}
	return string(b)
}
