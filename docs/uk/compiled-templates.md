# Скомпільований файл шаблонів (деталі реалізації)

Цей документ описує **згенерований Go-файл**, який створює `hbc` з шаблонів `.hbs`: як імена файлів шаблонів відповідають Go-символам і що саме випромінює компілятор.

Згенерований файл починається з `// Code generated by hbc; DO NOT EDIT.` і може містити `// Generator version: <version>`, якщо компілятор запускали з інформацією про версію (наприклад з CLI hbc).

## Ім'я шаблону → Go-ідентифікатор

Компілятор використовує **ім'я шаблону** = ім'я файлу без `.hbs` (наприклад `main.hbs` → `main`, `blog/post.hbs` → `blog/post`). З цього імені він отримує **Go-ідентифікатор** для імен функцій:

1. Розбити ім'я по будь-якому символу, що **не** є літерою або цифрою (`/`, `_`, `-`, пробіл тощо).
2. Зробити першу літеру кожної частини великою.
3. Склеїти частини.
4. Якщо результат порожній або починається з цифри — додати префікс `"Template"`.

| Файл шаблону   | Ім'я шаблону    | Go-ідентифікатор |
|----------------|-----------------|------------------|
| `main.hbs`     | `main`          | `Main`           |
| `header.hbs`   | `header`         | `Header`         |
| `blog/post.hbs`| `blog/post`     | `BlogPost`       |
| `compat_footer.hbs` | `compat_footer` | `CompatFooter`   |
| `404.hbs`      | `404`           | `Template404`    |
| `userCard.hbs` | `userCard`      | `UserCard`       |

Два різні імена шаблонів, що зводяться до одного Go-ідентифікатора (наприклад `blog-post` і `blog_post` → `BlogPost`), призводять до помилки компіляції: компілятор повідомляє про конфлікт.

## Згенерований API на шаблон

Для кожного імені шаблону згенерований пакет надає:

| Go-символ     | Сигнатура | Опис |
|---------------|-----------|------|
| `renderXxx`  | `func(data XxxContext, w io.Writer, root any) error` | Внутрішня: використовується партіалами та `RenderXxx`. Аргумент `root` — кореневий контекст (той самий, що `data`, коли шаблон рендериться як точка входу; коли шаблон використовується як партіал, викликач передає свій root, щоб `@root` у партіалі працював). Не призначена для прямого виклику. |
| `RenderXxx`   | `func(w io.Writer, data XxxContext) error` | Рендерить шаблон з `data` у `w`. |
| `RenderXxxString` | `func(data XxxContext) (string, error)` | Рендерить шаблон з `data` і повертає результат як рядок. |

Приклад для `main.hbs` (Go-ім'я `Main`):

```go
func renderMain(data MainContext, w io.Writer, root any) error { ... }
func RenderMain(w io.Writer, data MainContext) error { ... }
func RenderMainString(data MainContext) (string, error) { ... }
```

## Структура згенерованого файлу

1. **Пакет та імпорти**  
   Ім'я пакету (з `-pkg`), імпорти для `io`, `strings`, `runtime` та пакетів хелперів.

2. **Контекстні інтерфейси та типи**  
   Типобезпечні аксесори для шляхів контексту шаблону (виводяться з виразів у шаблоні). Компілятор випромінює інтерфейсні типи (наприклад `MainContext`, `MainContextUser`) та опційні конструктори `XxxContextFromMap`. Імена похідні від Go-ідентифікатора шаблону та шляху (наприклад `MainContextUser`, `MainContextItems`).

3. **Мапа partials**  
   Ключі — імена шаблонів (як у файлах без `.hbs`). Значення — функції `func(ctx any, w io.Writer, root any) error` (або з `*runtime.Blocks` при використанні блоків layout). Використовується, коли шаблон містить `{{> partialName }}` з явним контекстом або хешем. Якщо партіал викликано **без аргументів і без хешу** (наприклад `{{> header}}`), компілятор викликає `renderXxx(data, w, root)` з поточним контекстом та root викликача; при наявності явного контексту або хешу використовується мапа `partials`, щоб контекст перетворювався через `contextMap` та `XxxContextFromMap`. Аргумент `root` забезпечує, що `@root` у партіалах розв’язується до даних верхнього рівня (наприклад даних головного шаблону). Правила контексту партіала: без аргументів → поточний контекст; лише хеш → хеш плюс ключі, які партіал використовує (з поточного scope); явний контекст і/або хеш → базовий контекст, злитий з хешем.

4. **Функції**  
   Для кожного шаблону: `renderXxx`, `RenderXxx`, `RenderXxxString` як вище.

5. **Блок bootstrap** (лише з `-bootstrap`)  
   Див. [Згенерований bootstrap](bootstrap-generated.md).

## Підсумок

- **Ім'я шаблону** = ім'я файлу без `.hbs`.
- **Go-ім'я** = розбити по не-буквоцифровим, з великої літери кожну частину, склеїти; якщо порожньо або починається з цифри — префікс `Template`.
- **Публічний API**: `RenderXxx(w, data)` та `RenderXxxString(data)` з типізованим контекстом (наприклад `MainContext`); внутрішні `renderXxx` та `partials` — для компілятора/рантайму.

## Прапорці командного рядка hbc

| Прапорець | Опис |
|-----------|------|
| `-in` | Вхідний файл або директорія шаблонів (обов’язковий). |
| `-out` | Шлях до згенерованого Go-файлу (за замовчуванням: `templates_gen.go`). |
| `-pkg` | Ім’я пакету для згенерованого коду (за замовчуванням: з шляху виводу). |
| `-bootstrap` | Генерувати `NewQuickServer()` та `NewQuickProcessor()` для швидкого запуску сервера/процесора. |
| `-ext` | Розширення шаблонів через кому (за замовчуванням: `.hbs,.handlebars`). |
| `-runtime-import` | Перевизначити імпорт пакету runtime. |
| `-no-core-helpers` | Вимкнути вбудовані хелпери (з `helpers.Registry()`). |
| `-helper` | Зіставлення хелпера: `name=Ident` або `name=import/path:Ident`. |
| `-import` | Шлях імпорту для хелперів: `path` або `path:alias`. |
| `-helpers` | Список хелперів через кому: `[alias:]Name` або `[alias:]name=Ident`. |

Приклад: `hbc -in . -out ./templates_gen.go -pkg templates -bootstrap`
